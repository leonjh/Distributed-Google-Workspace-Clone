// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: masterserver.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_masterserver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_masterserver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_masterserver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_masterserver_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_masterserver_2eproto;
namespace backend {
class GetStorageServerStatusesRequest;
struct GetStorageServerStatusesRequestDefaultTypeInternal;
extern GetStorageServerStatusesRequestDefaultTypeInternal _GetStorageServerStatusesRequest_default_instance_;
class GetStorageServerStatusesResponse;
struct GetStorageServerStatusesResponseDefaultTypeInternal;
extern GetStorageServerStatusesResponseDefaultTypeInternal _GetStorageServerStatusesResponse_default_instance_;
class GetStorageServerStatusesResponse_ServerStatus;
struct GetStorageServerStatusesResponse_ServerStatusDefaultTypeInternal;
extern GetStorageServerStatusesResponse_ServerStatusDefaultTypeInternal _GetStorageServerStatusesResponse_ServerStatus_default_instance_;
class GetTabletsServerRequest;
struct GetTabletsServerRequestDefaultTypeInternal;
extern GetTabletsServerRequestDefaultTypeInternal _GetTabletsServerRequest_default_instance_;
class GetTabletsUserRequest;
struct GetTabletsUserRequestDefaultTypeInternal;
extern GetTabletsUserRequestDefaultTypeInternal _GetTabletsUserRequest_default_instance_;
class GetTabletsUserResponse;
struct GetTabletsUserResponseDefaultTypeInternal;
extern GetTabletsUserResponseDefaultTypeInternal _GetTabletsUserResponse_default_instance_;
class GetTabletsUserResponse_TabletGroup;
struct GetTabletsUserResponse_TabletGroupDefaultTypeInternal;
extern GetTabletsUserResponse_TabletGroupDefaultTypeInternal _GetTabletsUserResponse_TabletGroup_default_instance_;
class GetTabletsUserResponse_TabletGroup_ServerInfo;
struct GetTabletsUserResponse_TabletGroup_ServerInfoDefaultTypeInternal;
extern GetTabletsUserResponse_TabletGroup_ServerInfoDefaultTypeInternal _GetTabletsUserResponse_TabletGroup_ServerInfo_default_instance_;
class IsInitialStorageServerStartupRequest;
struct IsInitialStorageServerStartupRequestDefaultTypeInternal;
extern IsInitialStorageServerStartupRequestDefaultTypeInternal _IsInitialStorageServerStartupRequest_default_instance_;
class IsInitialStorageServerStartupResponse;
struct IsInitialStorageServerStartupResponseDefaultTypeInternal;
extern IsInitialStorageServerStartupResponseDefaultTypeInternal _IsInitialStorageServerStartupResponse_default_instance_;
class KillStorageServerRequest;
struct KillStorageServerRequestDefaultTypeInternal;
extern KillStorageServerRequestDefaultTypeInternal _KillStorageServerRequest_default_instance_;
class MasterEmpty;
struct MasterEmptyDefaultTypeInternal;
extern MasterEmptyDefaultTypeInternal _MasterEmpty_default_instance_;
class MasterGetKVStoreStateResponse;
struct MasterGetKVStoreStateResponseDefaultTypeInternal;
extern MasterGetKVStoreStateResponseDefaultTypeInternal _MasterGetKVStoreStateResponse_default_instance_;
class MasterGetKVStoreStateResponse_Row;
struct MasterGetKVStoreStateResponse_RowDefaultTypeInternal;
extern MasterGetKVStoreStateResponse_RowDefaultTypeInternal _MasterGetKVStoreStateResponse_Row_default_instance_;
class MasterGetKVStoreStateResponse_Row_Column;
struct MasterGetKVStoreStateResponse_Row_ColumnDefaultTypeInternal;
extern MasterGetKVStoreStateResponse_Row_ColumnDefaultTypeInternal _MasterGetKVStoreStateResponse_Row_Column_default_instance_;
}  // namespace backend
PROTOBUF_NAMESPACE_OPEN
template<> ::backend::GetStorageServerStatusesRequest* Arena::CreateMaybeMessage<::backend::GetStorageServerStatusesRequest>(Arena*);
template<> ::backend::GetStorageServerStatusesResponse* Arena::CreateMaybeMessage<::backend::GetStorageServerStatusesResponse>(Arena*);
template<> ::backend::GetStorageServerStatusesResponse_ServerStatus* Arena::CreateMaybeMessage<::backend::GetStorageServerStatusesResponse_ServerStatus>(Arena*);
template<> ::backend::GetTabletsServerRequest* Arena::CreateMaybeMessage<::backend::GetTabletsServerRequest>(Arena*);
template<> ::backend::GetTabletsUserRequest* Arena::CreateMaybeMessage<::backend::GetTabletsUserRequest>(Arena*);
template<> ::backend::GetTabletsUserResponse* Arena::CreateMaybeMessage<::backend::GetTabletsUserResponse>(Arena*);
template<> ::backend::GetTabletsUserResponse_TabletGroup* Arena::CreateMaybeMessage<::backend::GetTabletsUserResponse_TabletGroup>(Arena*);
template<> ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo* Arena::CreateMaybeMessage<::backend::GetTabletsUserResponse_TabletGroup_ServerInfo>(Arena*);
template<> ::backend::IsInitialStorageServerStartupRequest* Arena::CreateMaybeMessage<::backend::IsInitialStorageServerStartupRequest>(Arena*);
template<> ::backend::IsInitialStorageServerStartupResponse* Arena::CreateMaybeMessage<::backend::IsInitialStorageServerStartupResponse>(Arena*);
template<> ::backend::KillStorageServerRequest* Arena::CreateMaybeMessage<::backend::KillStorageServerRequest>(Arena*);
template<> ::backend::MasterEmpty* Arena::CreateMaybeMessage<::backend::MasterEmpty>(Arena*);
template<> ::backend::MasterGetKVStoreStateResponse* Arena::CreateMaybeMessage<::backend::MasterGetKVStoreStateResponse>(Arena*);
template<> ::backend::MasterGetKVStoreStateResponse_Row* Arena::CreateMaybeMessage<::backend::MasterGetKVStoreStateResponse_Row>(Arena*);
template<> ::backend::MasterGetKVStoreStateResponse_Row_Column* Arena::CreateMaybeMessage<::backend::MasterGetKVStoreStateResponse_Row_Column>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace backend {

// ===================================================================

class GetTabletsUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.GetTabletsUserRequest) */ {
 public:
  inline GetTabletsUserRequest() : GetTabletsUserRequest(nullptr) {}
  ~GetTabletsUserRequest() override;
  explicit PROTOBUF_CONSTEXPR GetTabletsUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTabletsUserRequest(const GetTabletsUserRequest& from);
  GetTabletsUserRequest(GetTabletsUserRequest&& from) noexcept
    : GetTabletsUserRequest() {
    *this = ::std::move(from);
  }

  inline GetTabletsUserRequest& operator=(const GetTabletsUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTabletsUserRequest& operator=(GetTabletsUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTabletsUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTabletsUserRequest* internal_default_instance() {
    return reinterpret_cast<const GetTabletsUserRequest*>(
               &_GetTabletsUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetTabletsUserRequest& a, GetTabletsUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTabletsUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTabletsUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTabletsUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTabletsUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTabletsUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTabletsUserRequest& from) {
    GetTabletsUserRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTabletsUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.GetTabletsUserRequest";
  }
  protected:
  explicit GetTabletsUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:backend.GetTabletsUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_masterserver_2eproto;
};
// -------------------------------------------------------------------

class GetTabletsServerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.GetTabletsServerRequest) */ {
 public:
  inline GetTabletsServerRequest() : GetTabletsServerRequest(nullptr) {}
  ~GetTabletsServerRequest() override;
  explicit PROTOBUF_CONSTEXPR GetTabletsServerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTabletsServerRequest(const GetTabletsServerRequest& from);
  GetTabletsServerRequest(GetTabletsServerRequest&& from) noexcept
    : GetTabletsServerRequest() {
    *this = ::std::move(from);
  }

  inline GetTabletsServerRequest& operator=(const GetTabletsServerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTabletsServerRequest& operator=(GetTabletsServerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTabletsServerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTabletsServerRequest* internal_default_instance() {
    return reinterpret_cast<const GetTabletsServerRequest*>(
               &_GetTabletsServerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetTabletsServerRequest& a, GetTabletsServerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTabletsServerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTabletsServerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTabletsServerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTabletsServerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTabletsServerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTabletsServerRequest& from) {
    GetTabletsServerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTabletsServerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.GetTabletsServerRequest";
  }
  protected:
  explicit GetTabletsServerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kPrimaryDownFieldNumber = 2,
    kPrimaryUpFieldNumber = 3,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // optional string primary_down = 2;
  bool has_primary_down() const;
  private:
  bool _internal_has_primary_down() const;
  public:
  void clear_primary_down();
  const std::string& primary_down() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_primary_down(ArgT0&& arg0, ArgT... args);
  std::string* mutable_primary_down();
  PROTOBUF_NODISCARD std::string* release_primary_down();
  void set_allocated_primary_down(std::string* primary_down);
  private:
  const std::string& _internal_primary_down() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_down(const std::string& value);
  std::string* _internal_mutable_primary_down();
  public:

  // optional string primary_up = 3;
  bool has_primary_up() const;
  private:
  bool _internal_has_primary_up() const;
  public:
  void clear_primary_up();
  const std::string& primary_up() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_primary_up(ArgT0&& arg0, ArgT... args);
  std::string* mutable_primary_up();
  PROTOBUF_NODISCARD std::string* release_primary_up();
  void set_allocated_primary_up(std::string* primary_up);
  private:
  const std::string& _internal_primary_up() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_up(const std::string& value);
  std::string* _internal_mutable_primary_up();
  public:

  // @@protoc_insertion_point(class_scope:backend.GetTabletsServerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr primary_down_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr primary_up_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_masterserver_2eproto;
};
// -------------------------------------------------------------------

class GetTabletsUserResponse_TabletGroup_ServerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.GetTabletsUserResponse.TabletGroup.ServerInfo) */ {
 public:
  inline GetTabletsUserResponse_TabletGroup_ServerInfo() : GetTabletsUserResponse_TabletGroup_ServerInfo(nullptr) {}
  ~GetTabletsUserResponse_TabletGroup_ServerInfo() override;
  explicit PROTOBUF_CONSTEXPR GetTabletsUserResponse_TabletGroup_ServerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTabletsUserResponse_TabletGroup_ServerInfo(const GetTabletsUserResponse_TabletGroup_ServerInfo& from);
  GetTabletsUserResponse_TabletGroup_ServerInfo(GetTabletsUserResponse_TabletGroup_ServerInfo&& from) noexcept
    : GetTabletsUserResponse_TabletGroup_ServerInfo() {
    *this = ::std::move(from);
  }

  inline GetTabletsUserResponse_TabletGroup_ServerInfo& operator=(const GetTabletsUserResponse_TabletGroup_ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTabletsUserResponse_TabletGroup_ServerInfo& operator=(GetTabletsUserResponse_TabletGroup_ServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTabletsUserResponse_TabletGroup_ServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTabletsUserResponse_TabletGroup_ServerInfo* internal_default_instance() {
    return reinterpret_cast<const GetTabletsUserResponse_TabletGroup_ServerInfo*>(
               &_GetTabletsUserResponse_TabletGroup_ServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetTabletsUserResponse_TabletGroup_ServerInfo& a, GetTabletsUserResponse_TabletGroup_ServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTabletsUserResponse_TabletGroup_ServerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTabletsUserResponse_TabletGroup_ServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTabletsUserResponse_TabletGroup_ServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTabletsUserResponse_TabletGroup_ServerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTabletsUserResponse_TabletGroup_ServerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTabletsUserResponse_TabletGroup_ServerInfo& from) {
    GetTabletsUserResponse_TabletGroup_ServerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTabletsUserResponse_TabletGroup_ServerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.GetTabletsUserResponse.TabletGroup.ServerInfo";
  }
  protected:
  explicit GetTabletsUserResponse_TabletGroup_ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:backend.GetTabletsUserResponse.TabletGroup.ServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_masterserver_2eproto;
};
// -------------------------------------------------------------------

class GetTabletsUserResponse_TabletGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.GetTabletsUserResponse.TabletGroup) */ {
 public:
  inline GetTabletsUserResponse_TabletGroup() : GetTabletsUserResponse_TabletGroup(nullptr) {}
  ~GetTabletsUserResponse_TabletGroup() override;
  explicit PROTOBUF_CONSTEXPR GetTabletsUserResponse_TabletGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTabletsUserResponse_TabletGroup(const GetTabletsUserResponse_TabletGroup& from);
  GetTabletsUserResponse_TabletGroup(GetTabletsUserResponse_TabletGroup&& from) noexcept
    : GetTabletsUserResponse_TabletGroup() {
    *this = ::std::move(from);
  }

  inline GetTabletsUserResponse_TabletGroup& operator=(const GetTabletsUserResponse_TabletGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTabletsUserResponse_TabletGroup& operator=(GetTabletsUserResponse_TabletGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTabletsUserResponse_TabletGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTabletsUserResponse_TabletGroup* internal_default_instance() {
    return reinterpret_cast<const GetTabletsUserResponse_TabletGroup*>(
               &_GetTabletsUserResponse_TabletGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetTabletsUserResponse_TabletGroup& a, GetTabletsUserResponse_TabletGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTabletsUserResponse_TabletGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTabletsUserResponse_TabletGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTabletsUserResponse_TabletGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTabletsUserResponse_TabletGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTabletsUserResponse_TabletGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTabletsUserResponse_TabletGroup& from) {
    GetTabletsUserResponse_TabletGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTabletsUserResponse_TabletGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.GetTabletsUserResponse.TabletGroup";
  }
  protected:
  explicit GetTabletsUserResponse_TabletGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetTabletsUserResponse_TabletGroup_ServerInfo ServerInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kServersFieldNumber = 3,
    kBeginFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // repeated .backend.GetTabletsUserResponse.TabletGroup.ServerInfo servers = 3;
  int servers_size() const;
  private:
  int _internal_servers_size() const;
  public:
  void clear_servers();
  ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo* mutable_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo >*
      mutable_servers();
  private:
  const ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo& _internal_servers(int index) const;
  ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo* _internal_add_servers();
  public:
  const ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo& servers(int index) const;
  ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo* add_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo >&
      servers() const;

  // string begin = 1;
  void clear_begin();
  const std::string& begin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_begin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_begin();
  PROTOBUF_NODISCARD std::string* release_begin();
  void set_allocated_begin(std::string* begin);
  private:
  const std::string& _internal_begin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_begin(const std::string& value);
  std::string* _internal_mutable_begin();
  public:

  // string end = 2;
  void clear_end();
  const std::string& end() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end();
  PROTOBUF_NODISCARD std::string* release_end();
  void set_allocated_end(std::string* end);
  private:
  const std::string& _internal_end() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end(const std::string& value);
  std::string* _internal_mutable_end();
  public:

  // @@protoc_insertion_point(class_scope:backend.GetTabletsUserResponse.TabletGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo > servers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr begin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_masterserver_2eproto;
};
// -------------------------------------------------------------------

class GetTabletsUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.GetTabletsUserResponse) */ {
 public:
  inline GetTabletsUserResponse() : GetTabletsUserResponse(nullptr) {}
  ~GetTabletsUserResponse() override;
  explicit PROTOBUF_CONSTEXPR GetTabletsUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTabletsUserResponse(const GetTabletsUserResponse& from);
  GetTabletsUserResponse(GetTabletsUserResponse&& from) noexcept
    : GetTabletsUserResponse() {
    *this = ::std::move(from);
  }

  inline GetTabletsUserResponse& operator=(const GetTabletsUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTabletsUserResponse& operator=(GetTabletsUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTabletsUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTabletsUserResponse* internal_default_instance() {
    return reinterpret_cast<const GetTabletsUserResponse*>(
               &_GetTabletsUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetTabletsUserResponse& a, GetTabletsUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTabletsUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTabletsUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTabletsUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTabletsUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTabletsUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTabletsUserResponse& from) {
    GetTabletsUserResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTabletsUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.GetTabletsUserResponse";
  }
  protected:
  explicit GetTabletsUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetTabletsUserResponse_TabletGroup TabletGroup;

  // accessors -------------------------------------------------------

  enum : int {
    kTabletsFieldNumber = 1,
  };
  // repeated .backend.GetTabletsUserResponse.TabletGroup tablets = 1;
  int tablets_size() const;
  private:
  int _internal_tablets_size() const;
  public:
  void clear_tablets();
  ::backend::GetTabletsUserResponse_TabletGroup* mutable_tablets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetTabletsUserResponse_TabletGroup >*
      mutable_tablets();
  private:
  const ::backend::GetTabletsUserResponse_TabletGroup& _internal_tablets(int index) const;
  ::backend::GetTabletsUserResponse_TabletGroup* _internal_add_tablets();
  public:
  const ::backend::GetTabletsUserResponse_TabletGroup& tablets(int index) const;
  ::backend::GetTabletsUserResponse_TabletGroup* add_tablets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetTabletsUserResponse_TabletGroup >&
      tablets() const;

  // @@protoc_insertion_point(class_scope:backend.GetTabletsUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetTabletsUserResponse_TabletGroup > tablets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_masterserver_2eproto;
};
// -------------------------------------------------------------------

class MasterEmpty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:backend.MasterEmpty) */ {
 public:
  inline MasterEmpty() : MasterEmpty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MasterEmpty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MasterEmpty(const MasterEmpty& from);
  MasterEmpty(MasterEmpty&& from) noexcept
    : MasterEmpty() {
    *this = ::std::move(from);
  }

  inline MasterEmpty& operator=(const MasterEmpty& from) {
    CopyFrom(from);
    return *this;
  }
  inline MasterEmpty& operator=(MasterEmpty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MasterEmpty& default_instance() {
    return *internal_default_instance();
  }
  static inline const MasterEmpty* internal_default_instance() {
    return reinterpret_cast<const MasterEmpty*>(
               &_MasterEmpty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MasterEmpty& a, MasterEmpty& b) {
    a.Swap(&b);
  }
  inline void Swap(MasterEmpty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MasterEmpty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MasterEmpty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MasterEmpty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MasterEmpty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MasterEmpty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.MasterEmpty";
  }
  protected:
  explicit MasterEmpty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:backend.MasterEmpty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_masterserver_2eproto;
};
// -------------------------------------------------------------------

class MasterGetKVStoreStateResponse_Row_Column final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.MasterGetKVStoreStateResponse.Row.Column) */ {
 public:
  inline MasterGetKVStoreStateResponse_Row_Column() : MasterGetKVStoreStateResponse_Row_Column(nullptr) {}
  ~MasterGetKVStoreStateResponse_Row_Column() override;
  explicit PROTOBUF_CONSTEXPR MasterGetKVStoreStateResponse_Row_Column(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MasterGetKVStoreStateResponse_Row_Column(const MasterGetKVStoreStateResponse_Row_Column& from);
  MasterGetKVStoreStateResponse_Row_Column(MasterGetKVStoreStateResponse_Row_Column&& from) noexcept
    : MasterGetKVStoreStateResponse_Row_Column() {
    *this = ::std::move(from);
  }

  inline MasterGetKVStoreStateResponse_Row_Column& operator=(const MasterGetKVStoreStateResponse_Row_Column& from) {
    CopyFrom(from);
    return *this;
  }
  inline MasterGetKVStoreStateResponse_Row_Column& operator=(MasterGetKVStoreStateResponse_Row_Column&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MasterGetKVStoreStateResponse_Row_Column& default_instance() {
    return *internal_default_instance();
  }
  static inline const MasterGetKVStoreStateResponse_Row_Column* internal_default_instance() {
    return reinterpret_cast<const MasterGetKVStoreStateResponse_Row_Column*>(
               &_MasterGetKVStoreStateResponse_Row_Column_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MasterGetKVStoreStateResponse_Row_Column& a, MasterGetKVStoreStateResponse_Row_Column& b) {
    a.Swap(&b);
  }
  inline void Swap(MasterGetKVStoreStateResponse_Row_Column* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MasterGetKVStoreStateResponse_Row_Column* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MasterGetKVStoreStateResponse_Row_Column* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MasterGetKVStoreStateResponse_Row_Column>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MasterGetKVStoreStateResponse_Row_Column& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MasterGetKVStoreStateResponse_Row_Column& from) {
    MasterGetKVStoreStateResponse_Row_Column::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterGetKVStoreStateResponse_Row_Column* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.MasterGetKVStoreStateResponse.Row.Column";
  }
  protected:
  explicit MasterGetKVStoreStateResponse_Row_Column(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:backend.MasterGetKVStoreStateResponse.Row.Column)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_masterserver_2eproto;
};
// -------------------------------------------------------------------

class MasterGetKVStoreStateResponse_Row final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.MasterGetKVStoreStateResponse.Row) */ {
 public:
  inline MasterGetKVStoreStateResponse_Row() : MasterGetKVStoreStateResponse_Row(nullptr) {}
  ~MasterGetKVStoreStateResponse_Row() override;
  explicit PROTOBUF_CONSTEXPR MasterGetKVStoreStateResponse_Row(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MasterGetKVStoreStateResponse_Row(const MasterGetKVStoreStateResponse_Row& from);
  MasterGetKVStoreStateResponse_Row(MasterGetKVStoreStateResponse_Row&& from) noexcept
    : MasterGetKVStoreStateResponse_Row() {
    *this = ::std::move(from);
  }

  inline MasterGetKVStoreStateResponse_Row& operator=(const MasterGetKVStoreStateResponse_Row& from) {
    CopyFrom(from);
    return *this;
  }
  inline MasterGetKVStoreStateResponse_Row& operator=(MasterGetKVStoreStateResponse_Row&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MasterGetKVStoreStateResponse_Row& default_instance() {
    return *internal_default_instance();
  }
  static inline const MasterGetKVStoreStateResponse_Row* internal_default_instance() {
    return reinterpret_cast<const MasterGetKVStoreStateResponse_Row*>(
               &_MasterGetKVStoreStateResponse_Row_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MasterGetKVStoreStateResponse_Row& a, MasterGetKVStoreStateResponse_Row& b) {
    a.Swap(&b);
  }
  inline void Swap(MasterGetKVStoreStateResponse_Row* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MasterGetKVStoreStateResponse_Row* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MasterGetKVStoreStateResponse_Row* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MasterGetKVStoreStateResponse_Row>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MasterGetKVStoreStateResponse_Row& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MasterGetKVStoreStateResponse_Row& from) {
    MasterGetKVStoreStateResponse_Row::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterGetKVStoreStateResponse_Row* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.MasterGetKVStoreStateResponse.Row";
  }
  protected:
  explicit MasterGetKVStoreStateResponse_Row(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MasterGetKVStoreStateResponse_Row_Column Column;

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .backend.MasterGetKVStoreStateResponse.Row.Column columns = 2;
  int columns_size() const;
  private:
  int _internal_columns_size() const;
  public:
  void clear_columns();
  ::backend::MasterGetKVStoreStateResponse_Row_Column* mutable_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::MasterGetKVStoreStateResponse_Row_Column >*
      mutable_columns();
  private:
  const ::backend::MasterGetKVStoreStateResponse_Row_Column& _internal_columns(int index) const;
  ::backend::MasterGetKVStoreStateResponse_Row_Column* _internal_add_columns();
  public:
  const ::backend::MasterGetKVStoreStateResponse_Row_Column& columns(int index) const;
  ::backend::MasterGetKVStoreStateResponse_Row_Column* add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::MasterGetKVStoreStateResponse_Row_Column >&
      columns() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:backend.MasterGetKVStoreStateResponse.Row)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::MasterGetKVStoreStateResponse_Row_Column > columns_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_masterserver_2eproto;
};
// -------------------------------------------------------------------

class MasterGetKVStoreStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.MasterGetKVStoreStateResponse) */ {
 public:
  inline MasterGetKVStoreStateResponse() : MasterGetKVStoreStateResponse(nullptr) {}
  ~MasterGetKVStoreStateResponse() override;
  explicit PROTOBUF_CONSTEXPR MasterGetKVStoreStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MasterGetKVStoreStateResponse(const MasterGetKVStoreStateResponse& from);
  MasterGetKVStoreStateResponse(MasterGetKVStoreStateResponse&& from) noexcept
    : MasterGetKVStoreStateResponse() {
    *this = ::std::move(from);
  }

  inline MasterGetKVStoreStateResponse& operator=(const MasterGetKVStoreStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MasterGetKVStoreStateResponse& operator=(MasterGetKVStoreStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MasterGetKVStoreStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MasterGetKVStoreStateResponse* internal_default_instance() {
    return reinterpret_cast<const MasterGetKVStoreStateResponse*>(
               &_MasterGetKVStoreStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MasterGetKVStoreStateResponse& a, MasterGetKVStoreStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MasterGetKVStoreStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MasterGetKVStoreStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MasterGetKVStoreStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MasterGetKVStoreStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MasterGetKVStoreStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MasterGetKVStoreStateResponse& from) {
    MasterGetKVStoreStateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterGetKVStoreStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.MasterGetKVStoreStateResponse";
  }
  protected:
  explicit MasterGetKVStoreStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MasterGetKVStoreStateResponse_Row Row;

  // accessors -------------------------------------------------------

  enum : int {
    kRowsFieldNumber = 1,
  };
  // repeated .backend.MasterGetKVStoreStateResponse.Row rows = 1;
  int rows_size() const;
  private:
  int _internal_rows_size() const;
  public:
  void clear_rows();
  ::backend::MasterGetKVStoreStateResponse_Row* mutable_rows(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::MasterGetKVStoreStateResponse_Row >*
      mutable_rows();
  private:
  const ::backend::MasterGetKVStoreStateResponse_Row& _internal_rows(int index) const;
  ::backend::MasterGetKVStoreStateResponse_Row* _internal_add_rows();
  public:
  const ::backend::MasterGetKVStoreStateResponse_Row& rows(int index) const;
  ::backend::MasterGetKVStoreStateResponse_Row* add_rows();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::MasterGetKVStoreStateResponse_Row >&
      rows() const;

  // @@protoc_insertion_point(class_scope:backend.MasterGetKVStoreStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::MasterGetKVStoreStateResponse_Row > rows_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_masterserver_2eproto;
};
// -------------------------------------------------------------------

class KillStorageServerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.KillStorageServerRequest) */ {
 public:
  inline KillStorageServerRequest() : KillStorageServerRequest(nullptr) {}
  ~KillStorageServerRequest() override;
  explicit PROTOBUF_CONSTEXPR KillStorageServerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KillStorageServerRequest(const KillStorageServerRequest& from);
  KillStorageServerRequest(KillStorageServerRequest&& from) noexcept
    : KillStorageServerRequest() {
    *this = ::std::move(from);
  }

  inline KillStorageServerRequest& operator=(const KillStorageServerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KillStorageServerRequest& operator=(KillStorageServerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KillStorageServerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KillStorageServerRequest* internal_default_instance() {
    return reinterpret_cast<const KillStorageServerRequest*>(
               &_KillStorageServerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(KillStorageServerRequest& a, KillStorageServerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KillStorageServerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KillStorageServerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KillStorageServerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KillStorageServerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KillStorageServerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KillStorageServerRequest& from) {
    KillStorageServerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KillStorageServerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.KillStorageServerRequest";
  }
  protected:
  explicit KillStorageServerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:backend.KillStorageServerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_masterserver_2eproto;
};
// -------------------------------------------------------------------

class IsInitialStorageServerStartupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.IsInitialStorageServerStartupRequest) */ {
 public:
  inline IsInitialStorageServerStartupRequest() : IsInitialStorageServerStartupRequest(nullptr) {}
  ~IsInitialStorageServerStartupRequest() override;
  explicit PROTOBUF_CONSTEXPR IsInitialStorageServerStartupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IsInitialStorageServerStartupRequest(const IsInitialStorageServerStartupRequest& from);
  IsInitialStorageServerStartupRequest(IsInitialStorageServerStartupRequest&& from) noexcept
    : IsInitialStorageServerStartupRequest() {
    *this = ::std::move(from);
  }

  inline IsInitialStorageServerStartupRequest& operator=(const IsInitialStorageServerStartupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsInitialStorageServerStartupRequest& operator=(IsInitialStorageServerStartupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsInitialStorageServerStartupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsInitialStorageServerStartupRequest* internal_default_instance() {
    return reinterpret_cast<const IsInitialStorageServerStartupRequest*>(
               &_IsInitialStorageServerStartupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(IsInitialStorageServerStartupRequest& a, IsInitialStorageServerStartupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(IsInitialStorageServerStartupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsInitialStorageServerStartupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsInitialStorageServerStartupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IsInitialStorageServerStartupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IsInitialStorageServerStartupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IsInitialStorageServerStartupRequest& from) {
    IsInitialStorageServerStartupRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsInitialStorageServerStartupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.IsInitialStorageServerStartupRequest";
  }
  protected:
  explicit IsInitialStorageServerStartupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:backend.IsInitialStorageServerStartupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_masterserver_2eproto;
};
// -------------------------------------------------------------------

class IsInitialStorageServerStartupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.IsInitialStorageServerStartupResponse) */ {
 public:
  inline IsInitialStorageServerStartupResponse() : IsInitialStorageServerStartupResponse(nullptr) {}
  ~IsInitialStorageServerStartupResponse() override;
  explicit PROTOBUF_CONSTEXPR IsInitialStorageServerStartupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IsInitialStorageServerStartupResponse(const IsInitialStorageServerStartupResponse& from);
  IsInitialStorageServerStartupResponse(IsInitialStorageServerStartupResponse&& from) noexcept
    : IsInitialStorageServerStartupResponse() {
    *this = ::std::move(from);
  }

  inline IsInitialStorageServerStartupResponse& operator=(const IsInitialStorageServerStartupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsInitialStorageServerStartupResponse& operator=(IsInitialStorageServerStartupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsInitialStorageServerStartupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsInitialStorageServerStartupResponse* internal_default_instance() {
    return reinterpret_cast<const IsInitialStorageServerStartupResponse*>(
               &_IsInitialStorageServerStartupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(IsInitialStorageServerStartupResponse& a, IsInitialStorageServerStartupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(IsInitialStorageServerStartupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsInitialStorageServerStartupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsInitialStorageServerStartupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IsInitialStorageServerStartupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IsInitialStorageServerStartupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IsInitialStorageServerStartupResponse& from) {
    IsInitialStorageServerStartupResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsInitialStorageServerStartupResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.IsInitialStorageServerStartupResponse";
  }
  protected:
  explicit IsInitialStorageServerStartupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsInitialFieldNumber = 1,
  };
  // bool is_initial = 1;
  void clear_is_initial();
  bool is_initial() const;
  void set_is_initial(bool value);
  private:
  bool _internal_is_initial() const;
  void _internal_set_is_initial(bool value);
  public:

  // @@protoc_insertion_point(class_scope:backend.IsInitialStorageServerStartupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool is_initial_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_masterserver_2eproto;
};
// -------------------------------------------------------------------

class GetStorageServerStatusesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:backend.GetStorageServerStatusesRequest) */ {
 public:
  inline GetStorageServerStatusesRequest() : GetStorageServerStatusesRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetStorageServerStatusesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStorageServerStatusesRequest(const GetStorageServerStatusesRequest& from);
  GetStorageServerStatusesRequest(GetStorageServerStatusesRequest&& from) noexcept
    : GetStorageServerStatusesRequest() {
    *this = ::std::move(from);
  }

  inline GetStorageServerStatusesRequest& operator=(const GetStorageServerStatusesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStorageServerStatusesRequest& operator=(GetStorageServerStatusesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStorageServerStatusesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStorageServerStatusesRequest* internal_default_instance() {
    return reinterpret_cast<const GetStorageServerStatusesRequest*>(
               &_GetStorageServerStatusesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetStorageServerStatusesRequest& a, GetStorageServerStatusesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStorageServerStatusesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStorageServerStatusesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStorageServerStatusesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStorageServerStatusesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetStorageServerStatusesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetStorageServerStatusesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.GetStorageServerStatusesRequest";
  }
  protected:
  explicit GetStorageServerStatusesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:backend.GetStorageServerStatusesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_masterserver_2eproto;
};
// -------------------------------------------------------------------

class GetStorageServerStatusesResponse_ServerStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.GetStorageServerStatusesResponse.ServerStatus) */ {
 public:
  inline GetStorageServerStatusesResponse_ServerStatus() : GetStorageServerStatusesResponse_ServerStatus(nullptr) {}
  ~GetStorageServerStatusesResponse_ServerStatus() override;
  explicit PROTOBUF_CONSTEXPR GetStorageServerStatusesResponse_ServerStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStorageServerStatusesResponse_ServerStatus(const GetStorageServerStatusesResponse_ServerStatus& from);
  GetStorageServerStatusesResponse_ServerStatus(GetStorageServerStatusesResponse_ServerStatus&& from) noexcept
    : GetStorageServerStatusesResponse_ServerStatus() {
    *this = ::std::move(from);
  }

  inline GetStorageServerStatusesResponse_ServerStatus& operator=(const GetStorageServerStatusesResponse_ServerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStorageServerStatusesResponse_ServerStatus& operator=(GetStorageServerStatusesResponse_ServerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStorageServerStatusesResponse_ServerStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStorageServerStatusesResponse_ServerStatus* internal_default_instance() {
    return reinterpret_cast<const GetStorageServerStatusesResponse_ServerStatus*>(
               &_GetStorageServerStatusesResponse_ServerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetStorageServerStatusesResponse_ServerStatus& a, GetStorageServerStatusesResponse_ServerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStorageServerStatusesResponse_ServerStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStorageServerStatusesResponse_ServerStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStorageServerStatusesResponse_ServerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStorageServerStatusesResponse_ServerStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStorageServerStatusesResponse_ServerStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStorageServerStatusesResponse_ServerStatus& from) {
    GetStorageServerStatusesResponse_ServerStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStorageServerStatusesResponse_ServerStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.GetStorageServerStatusesResponse.ServerStatus";
  }
  protected:
  explicit GetStorageServerStatusesResponse_ServerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kIsAliveFieldNumber = 2,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // bool is_alive = 2;
  void clear_is_alive();
  bool is_alive() const;
  void set_is_alive(bool value);
  private:
  bool _internal_is_alive() const;
  void _internal_set_is_alive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:backend.GetStorageServerStatusesResponse.ServerStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    bool is_alive_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_masterserver_2eproto;
};
// -------------------------------------------------------------------

class GetStorageServerStatusesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.GetStorageServerStatusesResponse) */ {
 public:
  inline GetStorageServerStatusesResponse() : GetStorageServerStatusesResponse(nullptr) {}
  ~GetStorageServerStatusesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetStorageServerStatusesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetStorageServerStatusesResponse(const GetStorageServerStatusesResponse& from);
  GetStorageServerStatusesResponse(GetStorageServerStatusesResponse&& from) noexcept
    : GetStorageServerStatusesResponse() {
    *this = ::std::move(from);
  }

  inline GetStorageServerStatusesResponse& operator=(const GetStorageServerStatusesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetStorageServerStatusesResponse& operator=(GetStorageServerStatusesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetStorageServerStatusesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetStorageServerStatusesResponse* internal_default_instance() {
    return reinterpret_cast<const GetStorageServerStatusesResponse*>(
               &_GetStorageServerStatusesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetStorageServerStatusesResponse& a, GetStorageServerStatusesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetStorageServerStatusesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetStorageServerStatusesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetStorageServerStatusesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetStorageServerStatusesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetStorageServerStatusesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetStorageServerStatusesResponse& from) {
    GetStorageServerStatusesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetStorageServerStatusesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.GetStorageServerStatusesResponse";
  }
  protected:
  explicit GetStorageServerStatusesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetStorageServerStatusesResponse_ServerStatus ServerStatus;

  // accessors -------------------------------------------------------

  enum : int {
    kStatusesFieldNumber = 1,
  };
  // repeated .backend.GetStorageServerStatusesResponse.ServerStatus statuses = 1;
  int statuses_size() const;
  private:
  int _internal_statuses_size() const;
  public:
  void clear_statuses();
  ::backend::GetStorageServerStatusesResponse_ServerStatus* mutable_statuses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetStorageServerStatusesResponse_ServerStatus >*
      mutable_statuses();
  private:
  const ::backend::GetStorageServerStatusesResponse_ServerStatus& _internal_statuses(int index) const;
  ::backend::GetStorageServerStatusesResponse_ServerStatus* _internal_add_statuses();
  public:
  const ::backend::GetStorageServerStatusesResponse_ServerStatus& statuses(int index) const;
  ::backend::GetStorageServerStatusesResponse_ServerStatus* add_statuses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetStorageServerStatusesResponse_ServerStatus >&
      statuses() const;

  // @@protoc_insertion_point(class_scope:backend.GetStorageServerStatusesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetStorageServerStatusesResponse_ServerStatus > statuses_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_masterserver_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetTabletsUserRequest

// string key = 1;
inline void GetTabletsUserRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& GetTabletsUserRequest::key() const {
  // @@protoc_insertion_point(field_get:backend.GetTabletsUserRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTabletsUserRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.GetTabletsUserRequest.key)
}
inline std::string* GetTabletsUserRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:backend.GetTabletsUserRequest.key)
  return _s;
}
inline const std::string& GetTabletsUserRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void GetTabletsUserRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTabletsUserRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTabletsUserRequest::release_key() {
  // @@protoc_insertion_point(field_release:backend.GetTabletsUserRequest.key)
  return _impl_.key_.Release();
}
inline void GetTabletsUserRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.GetTabletsUserRequest.key)
}

// -------------------------------------------------------------------

// GetTabletsServerRequest

// string address = 1;
inline void GetTabletsServerRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetTabletsServerRequest::address() const {
  // @@protoc_insertion_point(field_get:backend.GetTabletsServerRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTabletsServerRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.GetTabletsServerRequest.address)
}
inline std::string* GetTabletsServerRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:backend.GetTabletsServerRequest.address)
  return _s;
}
inline const std::string& GetTabletsServerRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetTabletsServerRequest::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTabletsServerRequest::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTabletsServerRequest::release_address() {
  // @@protoc_insertion_point(field_release:backend.GetTabletsServerRequest.address)
  return _impl_.address_.Release();
}
inline void GetTabletsServerRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.GetTabletsServerRequest.address)
}

// optional string primary_down = 2;
inline bool GetTabletsServerRequest::_internal_has_primary_down() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetTabletsServerRequest::has_primary_down() const {
  return _internal_has_primary_down();
}
inline void GetTabletsServerRequest::clear_primary_down() {
  _impl_.primary_down_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetTabletsServerRequest::primary_down() const {
  // @@protoc_insertion_point(field_get:backend.GetTabletsServerRequest.primary_down)
  return _internal_primary_down();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTabletsServerRequest::set_primary_down(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.primary_down_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.GetTabletsServerRequest.primary_down)
}
inline std::string* GetTabletsServerRequest::mutable_primary_down() {
  std::string* _s = _internal_mutable_primary_down();
  // @@protoc_insertion_point(field_mutable:backend.GetTabletsServerRequest.primary_down)
  return _s;
}
inline const std::string& GetTabletsServerRequest::_internal_primary_down() const {
  return _impl_.primary_down_.Get();
}
inline void GetTabletsServerRequest::_internal_set_primary_down(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.primary_down_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTabletsServerRequest::_internal_mutable_primary_down() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.primary_down_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTabletsServerRequest::release_primary_down() {
  // @@protoc_insertion_point(field_release:backend.GetTabletsServerRequest.primary_down)
  if (!_internal_has_primary_down()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.primary_down_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.primary_down_.IsDefault()) {
    _impl_.primary_down_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetTabletsServerRequest::set_allocated_primary_down(std::string* primary_down) {
  if (primary_down != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.primary_down_.SetAllocated(primary_down, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.primary_down_.IsDefault()) {
    _impl_.primary_down_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.GetTabletsServerRequest.primary_down)
}

// optional string primary_up = 3;
inline bool GetTabletsServerRequest::_internal_has_primary_up() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetTabletsServerRequest::has_primary_up() const {
  return _internal_has_primary_up();
}
inline void GetTabletsServerRequest::clear_primary_up() {
  _impl_.primary_up_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetTabletsServerRequest::primary_up() const {
  // @@protoc_insertion_point(field_get:backend.GetTabletsServerRequest.primary_up)
  return _internal_primary_up();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTabletsServerRequest::set_primary_up(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.primary_up_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.GetTabletsServerRequest.primary_up)
}
inline std::string* GetTabletsServerRequest::mutable_primary_up() {
  std::string* _s = _internal_mutable_primary_up();
  // @@protoc_insertion_point(field_mutable:backend.GetTabletsServerRequest.primary_up)
  return _s;
}
inline const std::string& GetTabletsServerRequest::_internal_primary_up() const {
  return _impl_.primary_up_.Get();
}
inline void GetTabletsServerRequest::_internal_set_primary_up(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.primary_up_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTabletsServerRequest::_internal_mutable_primary_up() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.primary_up_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTabletsServerRequest::release_primary_up() {
  // @@protoc_insertion_point(field_release:backend.GetTabletsServerRequest.primary_up)
  if (!_internal_has_primary_up()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.primary_up_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.primary_up_.IsDefault()) {
    _impl_.primary_up_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetTabletsServerRequest::set_allocated_primary_up(std::string* primary_up) {
  if (primary_up != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.primary_up_.SetAllocated(primary_up, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.primary_up_.IsDefault()) {
    _impl_.primary_up_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.GetTabletsServerRequest.primary_up)
}

// -------------------------------------------------------------------

// GetTabletsUserResponse_TabletGroup_ServerInfo

// string address = 1;
inline void GetTabletsUserResponse_TabletGroup_ServerInfo::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetTabletsUserResponse_TabletGroup_ServerInfo::address() const {
  // @@protoc_insertion_point(field_get:backend.GetTabletsUserResponse.TabletGroup.ServerInfo.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTabletsUserResponse_TabletGroup_ServerInfo::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.GetTabletsUserResponse.TabletGroup.ServerInfo.address)
}
inline std::string* GetTabletsUserResponse_TabletGroup_ServerInfo::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:backend.GetTabletsUserResponse.TabletGroup.ServerInfo.address)
  return _s;
}
inline const std::string& GetTabletsUserResponse_TabletGroup_ServerInfo::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetTabletsUserResponse_TabletGroup_ServerInfo::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTabletsUserResponse_TabletGroup_ServerInfo::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTabletsUserResponse_TabletGroup_ServerInfo::release_address() {
  // @@protoc_insertion_point(field_release:backend.GetTabletsUserResponse.TabletGroup.ServerInfo.address)
  return _impl_.address_.Release();
}
inline void GetTabletsUserResponse_TabletGroup_ServerInfo::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.GetTabletsUserResponse.TabletGroup.ServerInfo.address)
}

// -------------------------------------------------------------------

// GetTabletsUserResponse_TabletGroup

// string begin = 1;
inline void GetTabletsUserResponse_TabletGroup::clear_begin() {
  _impl_.begin_.ClearToEmpty();
}
inline const std::string& GetTabletsUserResponse_TabletGroup::begin() const {
  // @@protoc_insertion_point(field_get:backend.GetTabletsUserResponse.TabletGroup.begin)
  return _internal_begin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTabletsUserResponse_TabletGroup::set_begin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.begin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.GetTabletsUserResponse.TabletGroup.begin)
}
inline std::string* GetTabletsUserResponse_TabletGroup::mutable_begin() {
  std::string* _s = _internal_mutable_begin();
  // @@protoc_insertion_point(field_mutable:backend.GetTabletsUserResponse.TabletGroup.begin)
  return _s;
}
inline const std::string& GetTabletsUserResponse_TabletGroup::_internal_begin() const {
  return _impl_.begin_.Get();
}
inline void GetTabletsUserResponse_TabletGroup::_internal_set_begin(const std::string& value) {
  
  _impl_.begin_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTabletsUserResponse_TabletGroup::_internal_mutable_begin() {
  
  return _impl_.begin_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTabletsUserResponse_TabletGroup::release_begin() {
  // @@protoc_insertion_point(field_release:backend.GetTabletsUserResponse.TabletGroup.begin)
  return _impl_.begin_.Release();
}
inline void GetTabletsUserResponse_TabletGroup::set_allocated_begin(std::string* begin) {
  if (begin != nullptr) {
    
  } else {
    
  }
  _impl_.begin_.SetAllocated(begin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.begin_.IsDefault()) {
    _impl_.begin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.GetTabletsUserResponse.TabletGroup.begin)
}

// string end = 2;
inline void GetTabletsUserResponse_TabletGroup::clear_end() {
  _impl_.end_.ClearToEmpty();
}
inline const std::string& GetTabletsUserResponse_TabletGroup::end() const {
  // @@protoc_insertion_point(field_get:backend.GetTabletsUserResponse.TabletGroup.end)
  return _internal_end();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTabletsUserResponse_TabletGroup::set_end(ArgT0&& arg0, ArgT... args) {
 
 _impl_.end_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.GetTabletsUserResponse.TabletGroup.end)
}
inline std::string* GetTabletsUserResponse_TabletGroup::mutable_end() {
  std::string* _s = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:backend.GetTabletsUserResponse.TabletGroup.end)
  return _s;
}
inline const std::string& GetTabletsUserResponse_TabletGroup::_internal_end() const {
  return _impl_.end_.Get();
}
inline void GetTabletsUserResponse_TabletGroup::_internal_set_end(const std::string& value) {
  
  _impl_.end_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTabletsUserResponse_TabletGroup::_internal_mutable_end() {
  
  return _impl_.end_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTabletsUserResponse_TabletGroup::release_end() {
  // @@protoc_insertion_point(field_release:backend.GetTabletsUserResponse.TabletGroup.end)
  return _impl_.end_.Release();
}
inline void GetTabletsUserResponse_TabletGroup::set_allocated_end(std::string* end) {
  if (end != nullptr) {
    
  } else {
    
  }
  _impl_.end_.SetAllocated(end, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.end_.IsDefault()) {
    _impl_.end_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.GetTabletsUserResponse.TabletGroup.end)
}

// repeated .backend.GetTabletsUserResponse.TabletGroup.ServerInfo servers = 3;
inline int GetTabletsUserResponse_TabletGroup::_internal_servers_size() const {
  return _impl_.servers_.size();
}
inline int GetTabletsUserResponse_TabletGroup::servers_size() const {
  return _internal_servers_size();
}
inline void GetTabletsUserResponse_TabletGroup::clear_servers() {
  _impl_.servers_.Clear();
}
inline ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo* GetTabletsUserResponse_TabletGroup::mutable_servers(int index) {
  // @@protoc_insertion_point(field_mutable:backend.GetTabletsUserResponse.TabletGroup.servers)
  return _impl_.servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo >*
GetTabletsUserResponse_TabletGroup::mutable_servers() {
  // @@protoc_insertion_point(field_mutable_list:backend.GetTabletsUserResponse.TabletGroup.servers)
  return &_impl_.servers_;
}
inline const ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo& GetTabletsUserResponse_TabletGroup::_internal_servers(int index) const {
  return _impl_.servers_.Get(index);
}
inline const ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo& GetTabletsUserResponse_TabletGroup::servers(int index) const {
  // @@protoc_insertion_point(field_get:backend.GetTabletsUserResponse.TabletGroup.servers)
  return _internal_servers(index);
}
inline ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo* GetTabletsUserResponse_TabletGroup::_internal_add_servers() {
  return _impl_.servers_.Add();
}
inline ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo* GetTabletsUserResponse_TabletGroup::add_servers() {
  ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo* _add = _internal_add_servers();
  // @@protoc_insertion_point(field_add:backend.GetTabletsUserResponse.TabletGroup.servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetTabletsUserResponse_TabletGroup_ServerInfo >&
GetTabletsUserResponse_TabletGroup::servers() const {
  // @@protoc_insertion_point(field_list:backend.GetTabletsUserResponse.TabletGroup.servers)
  return _impl_.servers_;
}

// -------------------------------------------------------------------

// GetTabletsUserResponse

// repeated .backend.GetTabletsUserResponse.TabletGroup tablets = 1;
inline int GetTabletsUserResponse::_internal_tablets_size() const {
  return _impl_.tablets_.size();
}
inline int GetTabletsUserResponse::tablets_size() const {
  return _internal_tablets_size();
}
inline void GetTabletsUserResponse::clear_tablets() {
  _impl_.tablets_.Clear();
}
inline ::backend::GetTabletsUserResponse_TabletGroup* GetTabletsUserResponse::mutable_tablets(int index) {
  // @@protoc_insertion_point(field_mutable:backend.GetTabletsUserResponse.tablets)
  return _impl_.tablets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetTabletsUserResponse_TabletGroup >*
GetTabletsUserResponse::mutable_tablets() {
  // @@protoc_insertion_point(field_mutable_list:backend.GetTabletsUserResponse.tablets)
  return &_impl_.tablets_;
}
inline const ::backend::GetTabletsUserResponse_TabletGroup& GetTabletsUserResponse::_internal_tablets(int index) const {
  return _impl_.tablets_.Get(index);
}
inline const ::backend::GetTabletsUserResponse_TabletGroup& GetTabletsUserResponse::tablets(int index) const {
  // @@protoc_insertion_point(field_get:backend.GetTabletsUserResponse.tablets)
  return _internal_tablets(index);
}
inline ::backend::GetTabletsUserResponse_TabletGroup* GetTabletsUserResponse::_internal_add_tablets() {
  return _impl_.tablets_.Add();
}
inline ::backend::GetTabletsUserResponse_TabletGroup* GetTabletsUserResponse::add_tablets() {
  ::backend::GetTabletsUserResponse_TabletGroup* _add = _internal_add_tablets();
  // @@protoc_insertion_point(field_add:backend.GetTabletsUserResponse.tablets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetTabletsUserResponse_TabletGroup >&
GetTabletsUserResponse::tablets() const {
  // @@protoc_insertion_point(field_list:backend.GetTabletsUserResponse.tablets)
  return _impl_.tablets_;
}

// -------------------------------------------------------------------

// MasterEmpty

// -------------------------------------------------------------------

// MasterGetKVStoreStateResponse_Row_Column

// string name = 1;
inline void MasterGetKVStoreStateResponse_Row_Column::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MasterGetKVStoreStateResponse_Row_Column::name() const {
  // @@protoc_insertion_point(field_get:backend.MasterGetKVStoreStateResponse.Row.Column.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MasterGetKVStoreStateResponse_Row_Column::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.MasterGetKVStoreStateResponse.Row.Column.name)
}
inline std::string* MasterGetKVStoreStateResponse_Row_Column::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:backend.MasterGetKVStoreStateResponse.Row.Column.name)
  return _s;
}
inline const std::string& MasterGetKVStoreStateResponse_Row_Column::_internal_name() const {
  return _impl_.name_.Get();
}
inline void MasterGetKVStoreStateResponse_Row_Column::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MasterGetKVStoreStateResponse_Row_Column::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* MasterGetKVStoreStateResponse_Row_Column::release_name() {
  // @@protoc_insertion_point(field_release:backend.MasterGetKVStoreStateResponse.Row.Column.name)
  return _impl_.name_.Release();
}
inline void MasterGetKVStoreStateResponse_Row_Column::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.MasterGetKVStoreStateResponse.Row.Column.name)
}

// bytes data = 2;
inline void MasterGetKVStoreStateResponse_Row_Column::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& MasterGetKVStoreStateResponse_Row_Column::data() const {
  // @@protoc_insertion_point(field_get:backend.MasterGetKVStoreStateResponse.Row.Column.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MasterGetKVStoreStateResponse_Row_Column::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.MasterGetKVStoreStateResponse.Row.Column.data)
}
inline std::string* MasterGetKVStoreStateResponse_Row_Column::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:backend.MasterGetKVStoreStateResponse.Row.Column.data)
  return _s;
}
inline const std::string& MasterGetKVStoreStateResponse_Row_Column::_internal_data() const {
  return _impl_.data_.Get();
}
inline void MasterGetKVStoreStateResponse_Row_Column::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* MasterGetKVStoreStateResponse_Row_Column::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* MasterGetKVStoreStateResponse_Row_Column::release_data() {
  // @@protoc_insertion_point(field_release:backend.MasterGetKVStoreStateResponse.Row.Column.data)
  return _impl_.data_.Release();
}
inline void MasterGetKVStoreStateResponse_Row_Column::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.MasterGetKVStoreStateResponse.Row.Column.data)
}

// -------------------------------------------------------------------

// MasterGetKVStoreStateResponse_Row

// string name = 1;
inline void MasterGetKVStoreStateResponse_Row::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MasterGetKVStoreStateResponse_Row::name() const {
  // @@protoc_insertion_point(field_get:backend.MasterGetKVStoreStateResponse.Row.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MasterGetKVStoreStateResponse_Row::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.MasterGetKVStoreStateResponse.Row.name)
}
inline std::string* MasterGetKVStoreStateResponse_Row::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:backend.MasterGetKVStoreStateResponse.Row.name)
  return _s;
}
inline const std::string& MasterGetKVStoreStateResponse_Row::_internal_name() const {
  return _impl_.name_.Get();
}
inline void MasterGetKVStoreStateResponse_Row::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MasterGetKVStoreStateResponse_Row::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* MasterGetKVStoreStateResponse_Row::release_name() {
  // @@protoc_insertion_point(field_release:backend.MasterGetKVStoreStateResponse.Row.name)
  return _impl_.name_.Release();
}
inline void MasterGetKVStoreStateResponse_Row::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.MasterGetKVStoreStateResponse.Row.name)
}

// repeated .backend.MasterGetKVStoreStateResponse.Row.Column columns = 2;
inline int MasterGetKVStoreStateResponse_Row::_internal_columns_size() const {
  return _impl_.columns_.size();
}
inline int MasterGetKVStoreStateResponse_Row::columns_size() const {
  return _internal_columns_size();
}
inline void MasterGetKVStoreStateResponse_Row::clear_columns() {
  _impl_.columns_.Clear();
}
inline ::backend::MasterGetKVStoreStateResponse_Row_Column* MasterGetKVStoreStateResponse_Row::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:backend.MasterGetKVStoreStateResponse.Row.columns)
  return _impl_.columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::MasterGetKVStoreStateResponse_Row_Column >*
MasterGetKVStoreStateResponse_Row::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:backend.MasterGetKVStoreStateResponse.Row.columns)
  return &_impl_.columns_;
}
inline const ::backend::MasterGetKVStoreStateResponse_Row_Column& MasterGetKVStoreStateResponse_Row::_internal_columns(int index) const {
  return _impl_.columns_.Get(index);
}
inline const ::backend::MasterGetKVStoreStateResponse_Row_Column& MasterGetKVStoreStateResponse_Row::columns(int index) const {
  // @@protoc_insertion_point(field_get:backend.MasterGetKVStoreStateResponse.Row.columns)
  return _internal_columns(index);
}
inline ::backend::MasterGetKVStoreStateResponse_Row_Column* MasterGetKVStoreStateResponse_Row::_internal_add_columns() {
  return _impl_.columns_.Add();
}
inline ::backend::MasterGetKVStoreStateResponse_Row_Column* MasterGetKVStoreStateResponse_Row::add_columns() {
  ::backend::MasterGetKVStoreStateResponse_Row_Column* _add = _internal_add_columns();
  // @@protoc_insertion_point(field_add:backend.MasterGetKVStoreStateResponse.Row.columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::MasterGetKVStoreStateResponse_Row_Column >&
MasterGetKVStoreStateResponse_Row::columns() const {
  // @@protoc_insertion_point(field_list:backend.MasterGetKVStoreStateResponse.Row.columns)
  return _impl_.columns_;
}

// -------------------------------------------------------------------

// MasterGetKVStoreStateResponse

// repeated .backend.MasterGetKVStoreStateResponse.Row rows = 1;
inline int MasterGetKVStoreStateResponse::_internal_rows_size() const {
  return _impl_.rows_.size();
}
inline int MasterGetKVStoreStateResponse::rows_size() const {
  return _internal_rows_size();
}
inline void MasterGetKVStoreStateResponse::clear_rows() {
  _impl_.rows_.Clear();
}
inline ::backend::MasterGetKVStoreStateResponse_Row* MasterGetKVStoreStateResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:backend.MasterGetKVStoreStateResponse.rows)
  return _impl_.rows_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::MasterGetKVStoreStateResponse_Row >*
MasterGetKVStoreStateResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:backend.MasterGetKVStoreStateResponse.rows)
  return &_impl_.rows_;
}
inline const ::backend::MasterGetKVStoreStateResponse_Row& MasterGetKVStoreStateResponse::_internal_rows(int index) const {
  return _impl_.rows_.Get(index);
}
inline const ::backend::MasterGetKVStoreStateResponse_Row& MasterGetKVStoreStateResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:backend.MasterGetKVStoreStateResponse.rows)
  return _internal_rows(index);
}
inline ::backend::MasterGetKVStoreStateResponse_Row* MasterGetKVStoreStateResponse::_internal_add_rows() {
  return _impl_.rows_.Add();
}
inline ::backend::MasterGetKVStoreStateResponse_Row* MasterGetKVStoreStateResponse::add_rows() {
  ::backend::MasterGetKVStoreStateResponse_Row* _add = _internal_add_rows();
  // @@protoc_insertion_point(field_add:backend.MasterGetKVStoreStateResponse.rows)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::MasterGetKVStoreStateResponse_Row >&
MasterGetKVStoreStateResponse::rows() const {
  // @@protoc_insertion_point(field_list:backend.MasterGetKVStoreStateResponse.rows)
  return _impl_.rows_;
}

// -------------------------------------------------------------------

// KillStorageServerRequest

// string address = 1;
inline void KillStorageServerRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& KillStorageServerRequest::address() const {
  // @@protoc_insertion_point(field_get:backend.KillStorageServerRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KillStorageServerRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.KillStorageServerRequest.address)
}
inline std::string* KillStorageServerRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:backend.KillStorageServerRequest.address)
  return _s;
}
inline const std::string& KillStorageServerRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void KillStorageServerRequest::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* KillStorageServerRequest::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* KillStorageServerRequest::release_address() {
  // @@protoc_insertion_point(field_release:backend.KillStorageServerRequest.address)
  return _impl_.address_.Release();
}
inline void KillStorageServerRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.KillStorageServerRequest.address)
}

// -------------------------------------------------------------------

// IsInitialStorageServerStartupRequest

// string address = 1;
inline void IsInitialStorageServerStartupRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& IsInitialStorageServerStartupRequest::address() const {
  // @@protoc_insertion_point(field_get:backend.IsInitialStorageServerStartupRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IsInitialStorageServerStartupRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.IsInitialStorageServerStartupRequest.address)
}
inline std::string* IsInitialStorageServerStartupRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:backend.IsInitialStorageServerStartupRequest.address)
  return _s;
}
inline const std::string& IsInitialStorageServerStartupRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void IsInitialStorageServerStartupRequest::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* IsInitialStorageServerStartupRequest::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* IsInitialStorageServerStartupRequest::release_address() {
  // @@protoc_insertion_point(field_release:backend.IsInitialStorageServerStartupRequest.address)
  return _impl_.address_.Release();
}
inline void IsInitialStorageServerStartupRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.IsInitialStorageServerStartupRequest.address)
}

// -------------------------------------------------------------------

// IsInitialStorageServerStartupResponse

// bool is_initial = 1;
inline void IsInitialStorageServerStartupResponse::clear_is_initial() {
  _impl_.is_initial_ = false;
}
inline bool IsInitialStorageServerStartupResponse::_internal_is_initial() const {
  return _impl_.is_initial_;
}
inline bool IsInitialStorageServerStartupResponse::is_initial() const {
  // @@protoc_insertion_point(field_get:backend.IsInitialStorageServerStartupResponse.is_initial)
  return _internal_is_initial();
}
inline void IsInitialStorageServerStartupResponse::_internal_set_is_initial(bool value) {
  
  _impl_.is_initial_ = value;
}
inline void IsInitialStorageServerStartupResponse::set_is_initial(bool value) {
  _internal_set_is_initial(value);
  // @@protoc_insertion_point(field_set:backend.IsInitialStorageServerStartupResponse.is_initial)
}

// -------------------------------------------------------------------

// GetStorageServerStatusesRequest

// -------------------------------------------------------------------

// GetStorageServerStatusesResponse_ServerStatus

// string address = 1;
inline void GetStorageServerStatusesResponse_ServerStatus::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& GetStorageServerStatusesResponse_ServerStatus::address() const {
  // @@protoc_insertion_point(field_get:backend.GetStorageServerStatusesResponse.ServerStatus.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetStorageServerStatusesResponse_ServerStatus::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.GetStorageServerStatusesResponse.ServerStatus.address)
}
inline std::string* GetStorageServerStatusesResponse_ServerStatus::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:backend.GetStorageServerStatusesResponse.ServerStatus.address)
  return _s;
}
inline const std::string& GetStorageServerStatusesResponse_ServerStatus::_internal_address() const {
  return _impl_.address_.Get();
}
inline void GetStorageServerStatusesResponse_ServerStatus::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* GetStorageServerStatusesResponse_ServerStatus::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* GetStorageServerStatusesResponse_ServerStatus::release_address() {
  // @@protoc_insertion_point(field_release:backend.GetStorageServerStatusesResponse.ServerStatus.address)
  return _impl_.address_.Release();
}
inline void GetStorageServerStatusesResponse_ServerStatus::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.GetStorageServerStatusesResponse.ServerStatus.address)
}

// bool is_alive = 2;
inline void GetStorageServerStatusesResponse_ServerStatus::clear_is_alive() {
  _impl_.is_alive_ = false;
}
inline bool GetStorageServerStatusesResponse_ServerStatus::_internal_is_alive() const {
  return _impl_.is_alive_;
}
inline bool GetStorageServerStatusesResponse_ServerStatus::is_alive() const {
  // @@protoc_insertion_point(field_get:backend.GetStorageServerStatusesResponse.ServerStatus.is_alive)
  return _internal_is_alive();
}
inline void GetStorageServerStatusesResponse_ServerStatus::_internal_set_is_alive(bool value) {
  
  _impl_.is_alive_ = value;
}
inline void GetStorageServerStatusesResponse_ServerStatus::set_is_alive(bool value) {
  _internal_set_is_alive(value);
  // @@protoc_insertion_point(field_set:backend.GetStorageServerStatusesResponse.ServerStatus.is_alive)
}

// -------------------------------------------------------------------

// GetStorageServerStatusesResponse

// repeated .backend.GetStorageServerStatusesResponse.ServerStatus statuses = 1;
inline int GetStorageServerStatusesResponse::_internal_statuses_size() const {
  return _impl_.statuses_.size();
}
inline int GetStorageServerStatusesResponse::statuses_size() const {
  return _internal_statuses_size();
}
inline void GetStorageServerStatusesResponse::clear_statuses() {
  _impl_.statuses_.Clear();
}
inline ::backend::GetStorageServerStatusesResponse_ServerStatus* GetStorageServerStatusesResponse::mutable_statuses(int index) {
  // @@protoc_insertion_point(field_mutable:backend.GetStorageServerStatusesResponse.statuses)
  return _impl_.statuses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetStorageServerStatusesResponse_ServerStatus >*
GetStorageServerStatusesResponse::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:backend.GetStorageServerStatusesResponse.statuses)
  return &_impl_.statuses_;
}
inline const ::backend::GetStorageServerStatusesResponse_ServerStatus& GetStorageServerStatusesResponse::_internal_statuses(int index) const {
  return _impl_.statuses_.Get(index);
}
inline const ::backend::GetStorageServerStatusesResponse_ServerStatus& GetStorageServerStatusesResponse::statuses(int index) const {
  // @@protoc_insertion_point(field_get:backend.GetStorageServerStatusesResponse.statuses)
  return _internal_statuses(index);
}
inline ::backend::GetStorageServerStatusesResponse_ServerStatus* GetStorageServerStatusesResponse::_internal_add_statuses() {
  return _impl_.statuses_.Add();
}
inline ::backend::GetStorageServerStatusesResponse_ServerStatus* GetStorageServerStatusesResponse::add_statuses() {
  ::backend::GetStorageServerStatusesResponse_ServerStatus* _add = _internal_add_statuses();
  // @@protoc_insertion_point(field_add:backend.GetStorageServerStatusesResponse.statuses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::GetStorageServerStatusesResponse_ServerStatus >&
GetStorageServerStatusesResponse::statuses() const {
  // @@protoc_insertion_point(field_list:backend.GetStorageServerStatusesResponse.statuses)
  return _impl_.statuses_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace backend

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_masterserver_2eproto
