// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: storageserver.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_storageserver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_storageserver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_storageserver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_storageserver_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_storageserver_2eproto;
namespace backend {
class PushCheckpointPartitionRequest;
struct PushCheckpointPartitionRequestDefaultTypeInternal;
extern PushCheckpointPartitionRequestDefaultTypeInternal _PushCheckpointPartitionRequest_default_instance_;
class PushCheckpointPartitionResponse;
struct PushCheckpointPartitionResponseDefaultTypeInternal;
extern PushCheckpointPartitionResponseDefaultTypeInternal _PushCheckpointPartitionResponse_default_instance_;
class PushLogRequest;
struct PushLogRequestDefaultTypeInternal;
extern PushLogRequestDefaultTypeInternal _PushLogRequest_default_instance_;
class PushLogResponse;
struct PushLogResponseDefaultTypeInternal;
extern PushLogResponseDefaultTypeInternal _PushLogResponse_default_instance_;
class PushStorageTabletsRequest;
struct PushStorageTabletsRequestDefaultTypeInternal;
extern PushStorageTabletsRequestDefaultTypeInternal _PushStorageTabletsRequest_default_instance_;
class PushStorageTabletsRequest_TabletGroup;
struct PushStorageTabletsRequest_TabletGroupDefaultTypeInternal;
extern PushStorageTabletsRequest_TabletGroupDefaultTypeInternal _PushStorageTabletsRequest_TabletGroup_default_instance_;
class PushStorageTabletsRequest_TabletGroup_ServerInfo;
struct PushStorageTabletsRequest_TabletGroup_ServerInfoDefaultTypeInternal;
extern PushStorageTabletsRequest_TabletGroup_ServerInfoDefaultTypeInternal _PushStorageTabletsRequest_TabletGroup_ServerInfo_default_instance_;
class RequestLatestTabletStateRequest;
struct RequestLatestTabletStateRequestDefaultTypeInternal;
extern RequestLatestTabletStateRequestDefaultTypeInternal _RequestLatestTabletStateRequest_default_instance_;
class RequestLatestTabletStateResponse;
struct RequestLatestTabletStateResponseDefaultTypeInternal;
extern RequestLatestTabletStateResponseDefaultTypeInternal _RequestLatestTabletStateResponse_default_instance_;
class StorageEmpty;
struct StorageEmptyDefaultTypeInternal;
extern StorageEmptyDefaultTypeInternal _StorageEmpty_default_instance_;
class StorageGetKVStoreStateRequest;
struct StorageGetKVStoreStateRequestDefaultTypeInternal;
extern StorageGetKVStoreStateRequestDefaultTypeInternal _StorageGetKVStoreStateRequest_default_instance_;
class StorageGetKVStoreStateResponse;
struct StorageGetKVStoreStateResponseDefaultTypeInternal;
extern StorageGetKVStoreStateResponseDefaultTypeInternal _StorageGetKVStoreStateResponse_default_instance_;
class StorageGetKVStoreStateResponse_Row;
struct StorageGetKVStoreStateResponse_RowDefaultTypeInternal;
extern StorageGetKVStoreStateResponse_RowDefaultTypeInternal _StorageGetKVStoreStateResponse_Row_default_instance_;
class StorageGetKVStoreStateResponse_Row_Column;
struct StorageGetKVStoreStateResponse_Row_ColumnDefaultTypeInternal;
extern StorageGetKVStoreStateResponse_Row_ColumnDefaultTypeInternal _StorageGetKVStoreStateResponse_Row_Column_default_instance_;
class StorageServerRequest;
struct StorageServerRequestDefaultTypeInternal;
extern StorageServerRequestDefaultTypeInternal _StorageServerRequest_default_instance_;
class StorageServerResponse;
struct StorageServerResponseDefaultTypeInternal;
extern StorageServerResponseDefaultTypeInternal _StorageServerResponse_default_instance_;
}  // namespace backend
PROTOBUF_NAMESPACE_OPEN
template<> ::backend::PushCheckpointPartitionRequest* Arena::CreateMaybeMessage<::backend::PushCheckpointPartitionRequest>(Arena*);
template<> ::backend::PushCheckpointPartitionResponse* Arena::CreateMaybeMessage<::backend::PushCheckpointPartitionResponse>(Arena*);
template<> ::backend::PushLogRequest* Arena::CreateMaybeMessage<::backend::PushLogRequest>(Arena*);
template<> ::backend::PushLogResponse* Arena::CreateMaybeMessage<::backend::PushLogResponse>(Arena*);
template<> ::backend::PushStorageTabletsRequest* Arena::CreateMaybeMessage<::backend::PushStorageTabletsRequest>(Arena*);
template<> ::backend::PushStorageTabletsRequest_TabletGroup* Arena::CreateMaybeMessage<::backend::PushStorageTabletsRequest_TabletGroup>(Arena*);
template<> ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo* Arena::CreateMaybeMessage<::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo>(Arena*);
template<> ::backend::RequestLatestTabletStateRequest* Arena::CreateMaybeMessage<::backend::RequestLatestTabletStateRequest>(Arena*);
template<> ::backend::RequestLatestTabletStateResponse* Arena::CreateMaybeMessage<::backend::RequestLatestTabletStateResponse>(Arena*);
template<> ::backend::StorageEmpty* Arena::CreateMaybeMessage<::backend::StorageEmpty>(Arena*);
template<> ::backend::StorageGetKVStoreStateRequest* Arena::CreateMaybeMessage<::backend::StorageGetKVStoreStateRequest>(Arena*);
template<> ::backend::StorageGetKVStoreStateResponse* Arena::CreateMaybeMessage<::backend::StorageGetKVStoreStateResponse>(Arena*);
template<> ::backend::StorageGetKVStoreStateResponse_Row* Arena::CreateMaybeMessage<::backend::StorageGetKVStoreStateResponse_Row>(Arena*);
template<> ::backend::StorageGetKVStoreStateResponse_Row_Column* Arena::CreateMaybeMessage<::backend::StorageGetKVStoreStateResponse_Row_Column>(Arena*);
template<> ::backend::StorageServerRequest* Arena::CreateMaybeMessage<::backend::StorageServerRequest>(Arena*);
template<> ::backend::StorageServerResponse* Arena::CreateMaybeMessage<::backend::StorageServerResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace backend {

// ===================================================================

class PushStorageTabletsRequest_TabletGroup_ServerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.PushStorageTabletsRequest.TabletGroup.ServerInfo) */ {
 public:
  inline PushStorageTabletsRequest_TabletGroup_ServerInfo() : PushStorageTabletsRequest_TabletGroup_ServerInfo(nullptr) {}
  ~PushStorageTabletsRequest_TabletGroup_ServerInfo() override;
  explicit PROTOBUF_CONSTEXPR PushStorageTabletsRequest_TabletGroup_ServerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushStorageTabletsRequest_TabletGroup_ServerInfo(const PushStorageTabletsRequest_TabletGroup_ServerInfo& from);
  PushStorageTabletsRequest_TabletGroup_ServerInfo(PushStorageTabletsRequest_TabletGroup_ServerInfo&& from) noexcept
    : PushStorageTabletsRequest_TabletGroup_ServerInfo() {
    *this = ::std::move(from);
  }

  inline PushStorageTabletsRequest_TabletGroup_ServerInfo& operator=(const PushStorageTabletsRequest_TabletGroup_ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushStorageTabletsRequest_TabletGroup_ServerInfo& operator=(PushStorageTabletsRequest_TabletGroup_ServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushStorageTabletsRequest_TabletGroup_ServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushStorageTabletsRequest_TabletGroup_ServerInfo* internal_default_instance() {
    return reinterpret_cast<const PushStorageTabletsRequest_TabletGroup_ServerInfo*>(
               &_PushStorageTabletsRequest_TabletGroup_ServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PushStorageTabletsRequest_TabletGroup_ServerInfo& a, PushStorageTabletsRequest_TabletGroup_ServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PushStorageTabletsRequest_TabletGroup_ServerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushStorageTabletsRequest_TabletGroup_ServerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushStorageTabletsRequest_TabletGroup_ServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushStorageTabletsRequest_TabletGroup_ServerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushStorageTabletsRequest_TabletGroup_ServerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PushStorageTabletsRequest_TabletGroup_ServerInfo& from) {
    PushStorageTabletsRequest_TabletGroup_ServerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushStorageTabletsRequest_TabletGroup_ServerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.PushStorageTabletsRequest.TabletGroup.ServerInfo";
  }
  protected:
  explicit PushStorageTabletsRequest_TabletGroup_ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kPrimaryFieldNumber = 2,
  };
  // string address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // bool primary = 2;
  void clear_primary();
  bool primary() const;
  void set_primary(bool value);
  private:
  bool _internal_primary() const;
  void _internal_set_primary(bool value);
  public:

  // @@protoc_insertion_point(class_scope:backend.PushStorageTabletsRequest.TabletGroup.ServerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    bool primary_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class PushStorageTabletsRequest_TabletGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.PushStorageTabletsRequest.TabletGroup) */ {
 public:
  inline PushStorageTabletsRequest_TabletGroup() : PushStorageTabletsRequest_TabletGroup(nullptr) {}
  ~PushStorageTabletsRequest_TabletGroup() override;
  explicit PROTOBUF_CONSTEXPR PushStorageTabletsRequest_TabletGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushStorageTabletsRequest_TabletGroup(const PushStorageTabletsRequest_TabletGroup& from);
  PushStorageTabletsRequest_TabletGroup(PushStorageTabletsRequest_TabletGroup&& from) noexcept
    : PushStorageTabletsRequest_TabletGroup() {
    *this = ::std::move(from);
  }

  inline PushStorageTabletsRequest_TabletGroup& operator=(const PushStorageTabletsRequest_TabletGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushStorageTabletsRequest_TabletGroup& operator=(PushStorageTabletsRequest_TabletGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushStorageTabletsRequest_TabletGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushStorageTabletsRequest_TabletGroup* internal_default_instance() {
    return reinterpret_cast<const PushStorageTabletsRequest_TabletGroup*>(
               &_PushStorageTabletsRequest_TabletGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PushStorageTabletsRequest_TabletGroup& a, PushStorageTabletsRequest_TabletGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(PushStorageTabletsRequest_TabletGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushStorageTabletsRequest_TabletGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushStorageTabletsRequest_TabletGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushStorageTabletsRequest_TabletGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushStorageTabletsRequest_TabletGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PushStorageTabletsRequest_TabletGroup& from) {
    PushStorageTabletsRequest_TabletGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushStorageTabletsRequest_TabletGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.PushStorageTabletsRequest.TabletGroup";
  }
  protected:
  explicit PushStorageTabletsRequest_TabletGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PushStorageTabletsRequest_TabletGroup_ServerInfo ServerInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kServersFieldNumber = 3,
    kBeginFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // repeated .backend.PushStorageTabletsRequest.TabletGroup.ServerInfo servers = 3;
  int servers_size() const;
  private:
  int _internal_servers_size() const;
  public:
  void clear_servers();
  ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo* mutable_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo >*
      mutable_servers();
  private:
  const ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo& _internal_servers(int index) const;
  ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo* _internal_add_servers();
  public:
  const ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo& servers(int index) const;
  ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo* add_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo >&
      servers() const;

  // string begin = 1;
  void clear_begin();
  const std::string& begin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_begin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_begin();
  PROTOBUF_NODISCARD std::string* release_begin();
  void set_allocated_begin(std::string* begin);
  private:
  const std::string& _internal_begin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_begin(const std::string& value);
  std::string* _internal_mutable_begin();
  public:

  // string end = 2;
  void clear_end();
  const std::string& end() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end();
  PROTOBUF_NODISCARD std::string* release_end();
  void set_allocated_end(std::string* end);
  private:
  const std::string& _internal_end() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end(const std::string& value);
  std::string* _internal_mutable_end();
  public:

  // @@protoc_insertion_point(class_scope:backend.PushStorageTabletsRequest.TabletGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo > servers_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr begin_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class PushStorageTabletsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.PushStorageTabletsRequest) */ {
 public:
  inline PushStorageTabletsRequest() : PushStorageTabletsRequest(nullptr) {}
  ~PushStorageTabletsRequest() override;
  explicit PROTOBUF_CONSTEXPR PushStorageTabletsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushStorageTabletsRequest(const PushStorageTabletsRequest& from);
  PushStorageTabletsRequest(PushStorageTabletsRequest&& from) noexcept
    : PushStorageTabletsRequest() {
    *this = ::std::move(from);
  }

  inline PushStorageTabletsRequest& operator=(const PushStorageTabletsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushStorageTabletsRequest& operator=(PushStorageTabletsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushStorageTabletsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushStorageTabletsRequest* internal_default_instance() {
    return reinterpret_cast<const PushStorageTabletsRequest*>(
               &_PushStorageTabletsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PushStorageTabletsRequest& a, PushStorageTabletsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PushStorageTabletsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushStorageTabletsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushStorageTabletsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushStorageTabletsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushStorageTabletsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PushStorageTabletsRequest& from) {
    PushStorageTabletsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushStorageTabletsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.PushStorageTabletsRequest";
  }
  protected:
  explicit PushStorageTabletsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PushStorageTabletsRequest_TabletGroup TabletGroup;

  // accessors -------------------------------------------------------

  enum : int {
    kTabletsFieldNumber = 1,
  };
  // repeated .backend.PushStorageTabletsRequest.TabletGroup tablets = 1;
  int tablets_size() const;
  private:
  int _internal_tablets_size() const;
  public:
  void clear_tablets();
  ::backend::PushStorageTabletsRequest_TabletGroup* mutable_tablets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::PushStorageTabletsRequest_TabletGroup >*
      mutable_tablets();
  private:
  const ::backend::PushStorageTabletsRequest_TabletGroup& _internal_tablets(int index) const;
  ::backend::PushStorageTabletsRequest_TabletGroup* _internal_add_tablets();
  public:
  const ::backend::PushStorageTabletsRequest_TabletGroup& tablets(int index) const;
  ::backend::PushStorageTabletsRequest_TabletGroup* add_tablets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::PushStorageTabletsRequest_TabletGroup >&
      tablets() const;

  // @@protoc_insertion_point(class_scope:backend.PushStorageTabletsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::PushStorageTabletsRequest_TabletGroup > tablets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class StorageServerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.StorageServerRequest) */ {
 public:
  inline StorageServerRequest() : StorageServerRequest(nullptr) {}
  ~StorageServerRequest() override;
  explicit PROTOBUF_CONSTEXPR StorageServerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageServerRequest(const StorageServerRequest& from);
  StorageServerRequest(StorageServerRequest&& from) noexcept
    : StorageServerRequest() {
    *this = ::std::move(from);
  }

  inline StorageServerRequest& operator=(const StorageServerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageServerRequest& operator=(StorageServerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageServerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorageServerRequest* internal_default_instance() {
    return reinterpret_cast<const StorageServerRequest*>(
               &_StorageServerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StorageServerRequest& a, StorageServerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageServerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageServerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageServerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageServerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StorageServerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StorageServerRequest& from) {
    StorageServerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageServerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.StorageServerRequest";
  }
  protected:
  explicit StorageServerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kColFieldNumber = 2,
    kValue1FieldNumber = 4,
    kValue2FieldNumber = 5,
    kValue1BytesFieldNumber = 6,
    kValue2BytesFieldNumber = 7,
    kIsBytesFieldNumber = 3,
    kFromPrimaryFieldNumber = 8,
    kSequenceNumberFieldNumber = 9,
  };
  // string row = 1;
  void clear_row();
  const std::string& row() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_row(ArgT0&& arg0, ArgT... args);
  std::string* mutable_row();
  PROTOBUF_NODISCARD std::string* release_row();
  void set_allocated_row(std::string* row);
  private:
  const std::string& _internal_row() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_row(const std::string& value);
  std::string* _internal_mutable_row();
  public:

  // string col = 2;
  void clear_col();
  const std::string& col() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_col(ArgT0&& arg0, ArgT... args);
  std::string* mutable_col();
  PROTOBUF_NODISCARD std::string* release_col();
  void set_allocated_col(std::string* col);
  private:
  const std::string& _internal_col() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_col(const std::string& value);
  std::string* _internal_mutable_col();
  public:

  // optional string value1 = 4;
  bool has_value1() const;
  private:
  bool _internal_has_value1() const;
  public:
  void clear_value1();
  const std::string& value1() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value1(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value1();
  PROTOBUF_NODISCARD std::string* release_value1();
  void set_allocated_value1(std::string* value1);
  private:
  const std::string& _internal_value1() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value1(const std::string& value);
  std::string* _internal_mutable_value1();
  public:

  // optional string value2 = 5;
  bool has_value2() const;
  private:
  bool _internal_has_value2() const;
  public:
  void clear_value2();
  const std::string& value2() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value2(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value2();
  PROTOBUF_NODISCARD std::string* release_value2();
  void set_allocated_value2(std::string* value2);
  private:
  const std::string& _internal_value2() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value2(const std::string& value);
  std::string* _internal_mutable_value2();
  public:

  // optional bytes value1_bytes = 6;
  bool has_value1_bytes() const;
  private:
  bool _internal_has_value1_bytes() const;
  public:
  void clear_value1_bytes();
  const std::string& value1_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value1_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value1_bytes();
  PROTOBUF_NODISCARD std::string* release_value1_bytes();
  void set_allocated_value1_bytes(std::string* value1_bytes);
  private:
  const std::string& _internal_value1_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value1_bytes(const std::string& value);
  std::string* _internal_mutable_value1_bytes();
  public:

  // optional bytes value2_bytes = 7;
  bool has_value2_bytes() const;
  private:
  bool _internal_has_value2_bytes() const;
  public:
  void clear_value2_bytes();
  const std::string& value2_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value2_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value2_bytes();
  PROTOBUF_NODISCARD std::string* release_value2_bytes();
  void set_allocated_value2_bytes(std::string* value2_bytes);
  private:
  const std::string& _internal_value2_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value2_bytes(const std::string& value);
  std::string* _internal_mutable_value2_bytes();
  public:

  // optional bool is_bytes = 3;
  bool has_is_bytes() const;
  private:
  bool _internal_has_is_bytes() const;
  public:
  void clear_is_bytes();
  bool is_bytes() const;
  void set_is_bytes(bool value);
  private:
  bool _internal_is_bytes() const;
  void _internal_set_is_bytes(bool value);
  public:

  // bool from_primary = 8;
  void clear_from_primary();
  bool from_primary() const;
  void set_from_primary(bool value);
  private:
  bool _internal_from_primary() const;
  void _internal_set_from_primary(bool value);
  public:

  // optional int32 sequence_number = 9;
  bool has_sequence_number() const;
  private:
  bool _internal_has_sequence_number() const;
  public:
  void clear_sequence_number();
  int32_t sequence_number() const;
  void set_sequence_number(int32_t value);
  private:
  int32_t _internal_sequence_number() const;
  void _internal_set_sequence_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:backend.StorageServerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr col_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value1_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value2_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value1_bytes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value2_bytes_;
    bool is_bytes_;
    bool from_primary_;
    int32_t sequence_number_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class StorageServerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.StorageServerResponse) */ {
 public:
  inline StorageServerResponse() : StorageServerResponse(nullptr) {}
  ~StorageServerResponse() override;
  explicit PROTOBUF_CONSTEXPR StorageServerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageServerResponse(const StorageServerResponse& from);
  StorageServerResponse(StorageServerResponse&& from) noexcept
    : StorageServerResponse() {
    *this = ::std::move(from);
  }

  inline StorageServerResponse& operator=(const StorageServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageServerResponse& operator=(StorageServerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageServerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorageServerResponse* internal_default_instance() {
    return reinterpret_cast<const StorageServerResponse*>(
               &_StorageServerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StorageServerResponse& a, StorageServerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageServerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageServerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageServerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageServerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StorageServerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StorageServerResponse& from) {
    StorageServerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageServerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.StorageServerResponse";
  }
  protected:
  explicit StorageServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kValueBytesFieldNumber = 2,
  };
  // optional string value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // optional bytes value_bytes = 2;
  bool has_value_bytes() const;
  private:
  bool _internal_has_value_bytes() const;
  public:
  void clear_value_bytes();
  const std::string& value_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value_bytes();
  PROTOBUF_NODISCARD std::string* release_value_bytes();
  void set_allocated_value_bytes(std::string* value_bytes);
  private:
  const std::string& _internal_value_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value_bytes(const std::string& value);
  std::string* _internal_mutable_value_bytes();
  public:

  // @@protoc_insertion_point(class_scope:backend.StorageServerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_bytes_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class StorageEmpty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:backend.StorageEmpty) */ {
 public:
  inline StorageEmpty() : StorageEmpty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StorageEmpty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageEmpty(const StorageEmpty& from);
  StorageEmpty(StorageEmpty&& from) noexcept
    : StorageEmpty() {
    *this = ::std::move(from);
  }

  inline StorageEmpty& operator=(const StorageEmpty& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageEmpty& operator=(StorageEmpty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageEmpty& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorageEmpty* internal_default_instance() {
    return reinterpret_cast<const StorageEmpty*>(
               &_StorageEmpty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StorageEmpty& a, StorageEmpty& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageEmpty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageEmpty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageEmpty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageEmpty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StorageEmpty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StorageEmpty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.StorageEmpty";
  }
  protected:
  explicit StorageEmpty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:backend.StorageEmpty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class StorageGetKVStoreStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.StorageGetKVStoreStateRequest) */ {
 public:
  inline StorageGetKVStoreStateRequest() : StorageGetKVStoreStateRequest(nullptr) {}
  ~StorageGetKVStoreStateRequest() override;
  explicit PROTOBUF_CONSTEXPR StorageGetKVStoreStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageGetKVStoreStateRequest(const StorageGetKVStoreStateRequest& from);
  StorageGetKVStoreStateRequest(StorageGetKVStoreStateRequest&& from) noexcept
    : StorageGetKVStoreStateRequest() {
    *this = ::std::move(from);
  }

  inline StorageGetKVStoreStateRequest& operator=(const StorageGetKVStoreStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageGetKVStoreStateRequest& operator=(StorageGetKVStoreStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageGetKVStoreStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorageGetKVStoreStateRequest* internal_default_instance() {
    return reinterpret_cast<const StorageGetKVStoreStateRequest*>(
               &_StorageGetKVStoreStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StorageGetKVStoreStateRequest& a, StorageGetKVStoreStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageGetKVStoreStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageGetKVStoreStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageGetKVStoreStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageGetKVStoreStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StorageGetKVStoreStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StorageGetKVStoreStateRequest& from) {
    StorageGetKVStoreStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageGetKVStoreStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.StorageGetKVStoreStateRequest";
  }
  protected:
  explicit StorageGetKVStoreStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:backend.StorageGetKVStoreStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class StorageGetKVStoreStateResponse_Row_Column final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.StorageGetKVStoreStateResponse.Row.Column) */ {
 public:
  inline StorageGetKVStoreStateResponse_Row_Column() : StorageGetKVStoreStateResponse_Row_Column(nullptr) {}
  ~StorageGetKVStoreStateResponse_Row_Column() override;
  explicit PROTOBUF_CONSTEXPR StorageGetKVStoreStateResponse_Row_Column(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageGetKVStoreStateResponse_Row_Column(const StorageGetKVStoreStateResponse_Row_Column& from);
  StorageGetKVStoreStateResponse_Row_Column(StorageGetKVStoreStateResponse_Row_Column&& from) noexcept
    : StorageGetKVStoreStateResponse_Row_Column() {
    *this = ::std::move(from);
  }

  inline StorageGetKVStoreStateResponse_Row_Column& operator=(const StorageGetKVStoreStateResponse_Row_Column& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageGetKVStoreStateResponse_Row_Column& operator=(StorageGetKVStoreStateResponse_Row_Column&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageGetKVStoreStateResponse_Row_Column& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorageGetKVStoreStateResponse_Row_Column* internal_default_instance() {
    return reinterpret_cast<const StorageGetKVStoreStateResponse_Row_Column*>(
               &_StorageGetKVStoreStateResponse_Row_Column_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StorageGetKVStoreStateResponse_Row_Column& a, StorageGetKVStoreStateResponse_Row_Column& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageGetKVStoreStateResponse_Row_Column* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageGetKVStoreStateResponse_Row_Column* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageGetKVStoreStateResponse_Row_Column* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageGetKVStoreStateResponse_Row_Column>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StorageGetKVStoreStateResponse_Row_Column& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StorageGetKVStoreStateResponse_Row_Column& from) {
    StorageGetKVStoreStateResponse_Row_Column::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageGetKVStoreStateResponse_Row_Column* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.StorageGetKVStoreStateResponse.Row.Column";
  }
  protected:
  explicit StorageGetKVStoreStateResponse_Row_Column(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:backend.StorageGetKVStoreStateResponse.Row.Column)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class StorageGetKVStoreStateResponse_Row final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.StorageGetKVStoreStateResponse.Row) */ {
 public:
  inline StorageGetKVStoreStateResponse_Row() : StorageGetKVStoreStateResponse_Row(nullptr) {}
  ~StorageGetKVStoreStateResponse_Row() override;
  explicit PROTOBUF_CONSTEXPR StorageGetKVStoreStateResponse_Row(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageGetKVStoreStateResponse_Row(const StorageGetKVStoreStateResponse_Row& from);
  StorageGetKVStoreStateResponse_Row(StorageGetKVStoreStateResponse_Row&& from) noexcept
    : StorageGetKVStoreStateResponse_Row() {
    *this = ::std::move(from);
  }

  inline StorageGetKVStoreStateResponse_Row& operator=(const StorageGetKVStoreStateResponse_Row& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageGetKVStoreStateResponse_Row& operator=(StorageGetKVStoreStateResponse_Row&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageGetKVStoreStateResponse_Row& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorageGetKVStoreStateResponse_Row* internal_default_instance() {
    return reinterpret_cast<const StorageGetKVStoreStateResponse_Row*>(
               &_StorageGetKVStoreStateResponse_Row_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StorageGetKVStoreStateResponse_Row& a, StorageGetKVStoreStateResponse_Row& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageGetKVStoreStateResponse_Row* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageGetKVStoreStateResponse_Row* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageGetKVStoreStateResponse_Row* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageGetKVStoreStateResponse_Row>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StorageGetKVStoreStateResponse_Row& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StorageGetKVStoreStateResponse_Row& from) {
    StorageGetKVStoreStateResponse_Row::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageGetKVStoreStateResponse_Row* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.StorageGetKVStoreStateResponse.Row";
  }
  protected:
  explicit StorageGetKVStoreStateResponse_Row(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StorageGetKVStoreStateResponse_Row_Column Column;

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .backend.StorageGetKVStoreStateResponse.Row.Column columns = 2;
  int columns_size() const;
  private:
  int _internal_columns_size() const;
  public:
  void clear_columns();
  ::backend::StorageGetKVStoreStateResponse_Row_Column* mutable_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::StorageGetKVStoreStateResponse_Row_Column >*
      mutable_columns();
  private:
  const ::backend::StorageGetKVStoreStateResponse_Row_Column& _internal_columns(int index) const;
  ::backend::StorageGetKVStoreStateResponse_Row_Column* _internal_add_columns();
  public:
  const ::backend::StorageGetKVStoreStateResponse_Row_Column& columns(int index) const;
  ::backend::StorageGetKVStoreStateResponse_Row_Column* add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::StorageGetKVStoreStateResponse_Row_Column >&
      columns() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:backend.StorageGetKVStoreStateResponse.Row)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::StorageGetKVStoreStateResponse_Row_Column > columns_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class StorageGetKVStoreStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.StorageGetKVStoreStateResponse) */ {
 public:
  inline StorageGetKVStoreStateResponse() : StorageGetKVStoreStateResponse(nullptr) {}
  ~StorageGetKVStoreStateResponse() override;
  explicit PROTOBUF_CONSTEXPR StorageGetKVStoreStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorageGetKVStoreStateResponse(const StorageGetKVStoreStateResponse& from);
  StorageGetKVStoreStateResponse(StorageGetKVStoreStateResponse&& from) noexcept
    : StorageGetKVStoreStateResponse() {
    *this = ::std::move(from);
  }

  inline StorageGetKVStoreStateResponse& operator=(const StorageGetKVStoreStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageGetKVStoreStateResponse& operator=(StorageGetKVStoreStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageGetKVStoreStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorageGetKVStoreStateResponse* internal_default_instance() {
    return reinterpret_cast<const StorageGetKVStoreStateResponse*>(
               &_StorageGetKVStoreStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StorageGetKVStoreStateResponse& a, StorageGetKVStoreStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StorageGetKVStoreStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageGetKVStoreStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageGetKVStoreStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorageGetKVStoreStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StorageGetKVStoreStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StorageGetKVStoreStateResponse& from) {
    StorageGetKVStoreStateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorageGetKVStoreStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.StorageGetKVStoreStateResponse";
  }
  protected:
  explicit StorageGetKVStoreStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StorageGetKVStoreStateResponse_Row Row;

  // accessors -------------------------------------------------------

  enum : int {
    kRowsFieldNumber = 1,
  };
  // repeated .backend.StorageGetKVStoreStateResponse.Row rows = 1;
  int rows_size() const;
  private:
  int _internal_rows_size() const;
  public:
  void clear_rows();
  ::backend::StorageGetKVStoreStateResponse_Row* mutable_rows(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::StorageGetKVStoreStateResponse_Row >*
      mutable_rows();
  private:
  const ::backend::StorageGetKVStoreStateResponse_Row& _internal_rows(int index) const;
  ::backend::StorageGetKVStoreStateResponse_Row* _internal_add_rows();
  public:
  const ::backend::StorageGetKVStoreStateResponse_Row& rows(int index) const;
  ::backend::StorageGetKVStoreStateResponse_Row* add_rows();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::StorageGetKVStoreStateResponse_Row >&
      rows() const;

  // @@protoc_insertion_point(class_scope:backend.StorageGetKVStoreStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::StorageGetKVStoreStateResponse_Row > rows_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class RequestLatestTabletStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.RequestLatestTabletStateRequest) */ {
 public:
  inline RequestLatestTabletStateRequest() : RequestLatestTabletStateRequest(nullptr) {}
  ~RequestLatestTabletStateRequest() override;
  explicit PROTOBUF_CONSTEXPR RequestLatestTabletStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestLatestTabletStateRequest(const RequestLatestTabletStateRequest& from);
  RequestLatestTabletStateRequest(RequestLatestTabletStateRequest&& from) noexcept
    : RequestLatestTabletStateRequest() {
    *this = ::std::move(from);
  }

  inline RequestLatestTabletStateRequest& operator=(const RequestLatestTabletStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestLatestTabletStateRequest& operator=(RequestLatestTabletStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestLatestTabletStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestLatestTabletStateRequest* internal_default_instance() {
    return reinterpret_cast<const RequestLatestTabletStateRequest*>(
               &_RequestLatestTabletStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RequestLatestTabletStateRequest& a, RequestLatestTabletStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestLatestTabletStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestLatestTabletStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestLatestTabletStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestLatestTabletStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestLatestTabletStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestLatestTabletStateRequest& from) {
    RequestLatestTabletStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestLatestTabletStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.RequestLatestTabletStateRequest";
  }
  protected:
  explicit RequestLatestTabletStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTabletRangeFieldNumber = 1,
    kAddressFieldNumber = 4,
    kCheckpointVersionFieldNumber = 2,
    kLogLengthFieldNumber = 3,
  };
  // string tablet_range = 1;
  void clear_tablet_range();
  const std::string& tablet_range() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tablet_range(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tablet_range();
  PROTOBUF_NODISCARD std::string* release_tablet_range();
  void set_allocated_tablet_range(std::string* tablet_range);
  private:
  const std::string& _internal_tablet_range() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tablet_range(const std::string& value);
  std::string* _internal_mutable_tablet_range();
  public:

  // string address = 4;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // int32 checkpoint_version = 2;
  void clear_checkpoint_version();
  int32_t checkpoint_version() const;
  void set_checkpoint_version(int32_t value);
  private:
  int32_t _internal_checkpoint_version() const;
  void _internal_set_checkpoint_version(int32_t value);
  public:

  // int32 log_length = 3;
  void clear_log_length();
  int32_t log_length() const;
  void set_log_length(int32_t value);
  private:
  int32_t _internal_log_length() const;
  void _internal_set_log_length(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:backend.RequestLatestTabletStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tablet_range_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    int32_t checkpoint_version_;
    int32_t log_length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class RequestLatestTabletStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:backend.RequestLatestTabletStateResponse) */ {
 public:
  inline RequestLatestTabletStateResponse() : RequestLatestTabletStateResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RequestLatestTabletStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestLatestTabletStateResponse(const RequestLatestTabletStateResponse& from);
  RequestLatestTabletStateResponse(RequestLatestTabletStateResponse&& from) noexcept
    : RequestLatestTabletStateResponse() {
    *this = ::std::move(from);
  }

  inline RequestLatestTabletStateResponse& operator=(const RequestLatestTabletStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestLatestTabletStateResponse& operator=(RequestLatestTabletStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestLatestTabletStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestLatestTabletStateResponse* internal_default_instance() {
    return reinterpret_cast<const RequestLatestTabletStateResponse*>(
               &_RequestLatestTabletStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RequestLatestTabletStateResponse& a, RequestLatestTabletStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestLatestTabletStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestLatestTabletStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestLatestTabletStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestLatestTabletStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RequestLatestTabletStateResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RequestLatestTabletStateResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.RequestLatestTabletStateResponse";
  }
  protected:
  explicit RequestLatestTabletStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:backend.RequestLatestTabletStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class PushCheckpointPartitionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.PushCheckpointPartitionRequest) */ {
 public:
  inline PushCheckpointPartitionRequest() : PushCheckpointPartitionRequest(nullptr) {}
  ~PushCheckpointPartitionRequest() override;
  explicit PROTOBUF_CONSTEXPR PushCheckpointPartitionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushCheckpointPartitionRequest(const PushCheckpointPartitionRequest& from);
  PushCheckpointPartitionRequest(PushCheckpointPartitionRequest&& from) noexcept
    : PushCheckpointPartitionRequest() {
    *this = ::std::move(from);
  }

  inline PushCheckpointPartitionRequest& operator=(const PushCheckpointPartitionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushCheckpointPartitionRequest& operator=(PushCheckpointPartitionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushCheckpointPartitionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushCheckpointPartitionRequest* internal_default_instance() {
    return reinterpret_cast<const PushCheckpointPartitionRequest*>(
               &_PushCheckpointPartitionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PushCheckpointPartitionRequest& a, PushCheckpointPartitionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PushCheckpointPartitionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushCheckpointPartitionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushCheckpointPartitionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushCheckpointPartitionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushCheckpointPartitionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PushCheckpointPartitionRequest& from) {
    PushCheckpointPartitionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushCheckpointPartitionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.PushCheckpointPartitionRequest";
  }
  protected:
  explicit PushCheckpointPartitionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTabletRangeFieldNumber = 2,
    kContentFieldNumber = 3,
    kCheckpointVersionFieldNumber = 1,
    kIsLastPartitionFieldNumber = 4,
  };
  // string tablet_range = 2;
  void clear_tablet_range();
  const std::string& tablet_range() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tablet_range(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tablet_range();
  PROTOBUF_NODISCARD std::string* release_tablet_range();
  void set_allocated_tablet_range(std::string* tablet_range);
  private:
  const std::string& _internal_tablet_range() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tablet_range(const std::string& value);
  std::string* _internal_mutable_tablet_range();
  public:

  // bytes content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // int32 checkpoint_version = 1;
  void clear_checkpoint_version();
  int32_t checkpoint_version() const;
  void set_checkpoint_version(int32_t value);
  private:
  int32_t _internal_checkpoint_version() const;
  void _internal_set_checkpoint_version(int32_t value);
  public:

  // bool is_last_partition = 4;
  void clear_is_last_partition();
  bool is_last_partition() const;
  void set_is_last_partition(bool value);
  private:
  bool _internal_is_last_partition() const;
  void _internal_set_is_last_partition(bool value);
  public:

  // @@protoc_insertion_point(class_scope:backend.PushCheckpointPartitionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tablet_range_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    int32_t checkpoint_version_;
    bool is_last_partition_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class PushCheckpointPartitionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:backend.PushCheckpointPartitionResponse) */ {
 public:
  inline PushCheckpointPartitionResponse() : PushCheckpointPartitionResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PushCheckpointPartitionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushCheckpointPartitionResponse(const PushCheckpointPartitionResponse& from);
  PushCheckpointPartitionResponse(PushCheckpointPartitionResponse&& from) noexcept
    : PushCheckpointPartitionResponse() {
    *this = ::std::move(from);
  }

  inline PushCheckpointPartitionResponse& operator=(const PushCheckpointPartitionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushCheckpointPartitionResponse& operator=(PushCheckpointPartitionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushCheckpointPartitionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushCheckpointPartitionResponse* internal_default_instance() {
    return reinterpret_cast<const PushCheckpointPartitionResponse*>(
               &_PushCheckpointPartitionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PushCheckpointPartitionResponse& a, PushCheckpointPartitionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PushCheckpointPartitionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushCheckpointPartitionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushCheckpointPartitionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushCheckpointPartitionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PushCheckpointPartitionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PushCheckpointPartitionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.PushCheckpointPartitionResponse";
  }
  protected:
  explicit PushCheckpointPartitionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:backend.PushCheckpointPartitionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class PushLogRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backend.PushLogRequest) */ {
 public:
  inline PushLogRequest() : PushLogRequest(nullptr) {}
  ~PushLogRequest() override;
  explicit PROTOBUF_CONSTEXPR PushLogRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushLogRequest(const PushLogRequest& from);
  PushLogRequest(PushLogRequest&& from) noexcept
    : PushLogRequest() {
    *this = ::std::move(from);
  }

  inline PushLogRequest& operator=(const PushLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushLogRequest& operator=(PushLogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushLogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushLogRequest* internal_default_instance() {
    return reinterpret_cast<const PushLogRequest*>(
               &_PushLogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PushLogRequest& a, PushLogRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PushLogRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushLogRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushLogRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushLogRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushLogRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PushLogRequest& from) {
    PushLogRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushLogRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.PushLogRequest";
  }
  protected:
  explicit PushLogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTabletRangeFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // string tablet_range = 1;
  void clear_tablet_range();
  const std::string& tablet_range() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tablet_range(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tablet_range();
  PROTOBUF_NODISCARD std::string* release_tablet_range();
  void set_allocated_tablet_range(std::string* tablet_range);
  private:
  const std::string& _internal_tablet_range() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tablet_range(const std::string& value);
  std::string* _internal_mutable_tablet_range();
  public:

  // bytes content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:backend.PushLogRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tablet_range_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_storageserver_2eproto;
};
// -------------------------------------------------------------------

class PushLogResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:backend.PushLogResponse) */ {
 public:
  inline PushLogResponse() : PushLogResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PushLogResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushLogResponse(const PushLogResponse& from);
  PushLogResponse(PushLogResponse&& from) noexcept
    : PushLogResponse() {
    *this = ::std::move(from);
  }

  inline PushLogResponse& operator=(const PushLogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushLogResponse& operator=(PushLogResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushLogResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushLogResponse* internal_default_instance() {
    return reinterpret_cast<const PushLogResponse*>(
               &_PushLogResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PushLogResponse& a, PushLogResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PushLogResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushLogResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushLogResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushLogResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PushLogResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PushLogResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backend.PushLogResponse";
  }
  protected:
  explicit PushLogResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:backend.PushLogResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_storageserver_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PushStorageTabletsRequest_TabletGroup_ServerInfo

// string address = 1;
inline void PushStorageTabletsRequest_TabletGroup_ServerInfo::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& PushStorageTabletsRequest_TabletGroup_ServerInfo::address() const {
  // @@protoc_insertion_point(field_get:backend.PushStorageTabletsRequest.TabletGroup.ServerInfo.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushStorageTabletsRequest_TabletGroup_ServerInfo::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.PushStorageTabletsRequest.TabletGroup.ServerInfo.address)
}
inline std::string* PushStorageTabletsRequest_TabletGroup_ServerInfo::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:backend.PushStorageTabletsRequest.TabletGroup.ServerInfo.address)
  return _s;
}
inline const std::string& PushStorageTabletsRequest_TabletGroup_ServerInfo::_internal_address() const {
  return _impl_.address_.Get();
}
inline void PushStorageTabletsRequest_TabletGroup_ServerInfo::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* PushStorageTabletsRequest_TabletGroup_ServerInfo::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* PushStorageTabletsRequest_TabletGroup_ServerInfo::release_address() {
  // @@protoc_insertion_point(field_release:backend.PushStorageTabletsRequest.TabletGroup.ServerInfo.address)
  return _impl_.address_.Release();
}
inline void PushStorageTabletsRequest_TabletGroup_ServerInfo::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.PushStorageTabletsRequest.TabletGroup.ServerInfo.address)
}

// bool primary = 2;
inline void PushStorageTabletsRequest_TabletGroup_ServerInfo::clear_primary() {
  _impl_.primary_ = false;
}
inline bool PushStorageTabletsRequest_TabletGroup_ServerInfo::_internal_primary() const {
  return _impl_.primary_;
}
inline bool PushStorageTabletsRequest_TabletGroup_ServerInfo::primary() const {
  // @@protoc_insertion_point(field_get:backend.PushStorageTabletsRequest.TabletGroup.ServerInfo.primary)
  return _internal_primary();
}
inline void PushStorageTabletsRequest_TabletGroup_ServerInfo::_internal_set_primary(bool value) {
  
  _impl_.primary_ = value;
}
inline void PushStorageTabletsRequest_TabletGroup_ServerInfo::set_primary(bool value) {
  _internal_set_primary(value);
  // @@protoc_insertion_point(field_set:backend.PushStorageTabletsRequest.TabletGroup.ServerInfo.primary)
}

// -------------------------------------------------------------------

// PushStorageTabletsRequest_TabletGroup

// string begin = 1;
inline void PushStorageTabletsRequest_TabletGroup::clear_begin() {
  _impl_.begin_.ClearToEmpty();
}
inline const std::string& PushStorageTabletsRequest_TabletGroup::begin() const {
  // @@protoc_insertion_point(field_get:backend.PushStorageTabletsRequest.TabletGroup.begin)
  return _internal_begin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushStorageTabletsRequest_TabletGroup::set_begin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.begin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.PushStorageTabletsRequest.TabletGroup.begin)
}
inline std::string* PushStorageTabletsRequest_TabletGroup::mutable_begin() {
  std::string* _s = _internal_mutable_begin();
  // @@protoc_insertion_point(field_mutable:backend.PushStorageTabletsRequest.TabletGroup.begin)
  return _s;
}
inline const std::string& PushStorageTabletsRequest_TabletGroup::_internal_begin() const {
  return _impl_.begin_.Get();
}
inline void PushStorageTabletsRequest_TabletGroup::_internal_set_begin(const std::string& value) {
  
  _impl_.begin_.Set(value, GetArenaForAllocation());
}
inline std::string* PushStorageTabletsRequest_TabletGroup::_internal_mutable_begin() {
  
  return _impl_.begin_.Mutable(GetArenaForAllocation());
}
inline std::string* PushStorageTabletsRequest_TabletGroup::release_begin() {
  // @@protoc_insertion_point(field_release:backend.PushStorageTabletsRequest.TabletGroup.begin)
  return _impl_.begin_.Release();
}
inline void PushStorageTabletsRequest_TabletGroup::set_allocated_begin(std::string* begin) {
  if (begin != nullptr) {
    
  } else {
    
  }
  _impl_.begin_.SetAllocated(begin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.begin_.IsDefault()) {
    _impl_.begin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.PushStorageTabletsRequest.TabletGroup.begin)
}

// string end = 2;
inline void PushStorageTabletsRequest_TabletGroup::clear_end() {
  _impl_.end_.ClearToEmpty();
}
inline const std::string& PushStorageTabletsRequest_TabletGroup::end() const {
  // @@protoc_insertion_point(field_get:backend.PushStorageTabletsRequest.TabletGroup.end)
  return _internal_end();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushStorageTabletsRequest_TabletGroup::set_end(ArgT0&& arg0, ArgT... args) {
 
 _impl_.end_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.PushStorageTabletsRequest.TabletGroup.end)
}
inline std::string* PushStorageTabletsRequest_TabletGroup::mutable_end() {
  std::string* _s = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:backend.PushStorageTabletsRequest.TabletGroup.end)
  return _s;
}
inline const std::string& PushStorageTabletsRequest_TabletGroup::_internal_end() const {
  return _impl_.end_.Get();
}
inline void PushStorageTabletsRequest_TabletGroup::_internal_set_end(const std::string& value) {
  
  _impl_.end_.Set(value, GetArenaForAllocation());
}
inline std::string* PushStorageTabletsRequest_TabletGroup::_internal_mutable_end() {
  
  return _impl_.end_.Mutable(GetArenaForAllocation());
}
inline std::string* PushStorageTabletsRequest_TabletGroup::release_end() {
  // @@protoc_insertion_point(field_release:backend.PushStorageTabletsRequest.TabletGroup.end)
  return _impl_.end_.Release();
}
inline void PushStorageTabletsRequest_TabletGroup::set_allocated_end(std::string* end) {
  if (end != nullptr) {
    
  } else {
    
  }
  _impl_.end_.SetAllocated(end, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.end_.IsDefault()) {
    _impl_.end_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.PushStorageTabletsRequest.TabletGroup.end)
}

// repeated .backend.PushStorageTabletsRequest.TabletGroup.ServerInfo servers = 3;
inline int PushStorageTabletsRequest_TabletGroup::_internal_servers_size() const {
  return _impl_.servers_.size();
}
inline int PushStorageTabletsRequest_TabletGroup::servers_size() const {
  return _internal_servers_size();
}
inline void PushStorageTabletsRequest_TabletGroup::clear_servers() {
  _impl_.servers_.Clear();
}
inline ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo* PushStorageTabletsRequest_TabletGroup::mutable_servers(int index) {
  // @@protoc_insertion_point(field_mutable:backend.PushStorageTabletsRequest.TabletGroup.servers)
  return _impl_.servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo >*
PushStorageTabletsRequest_TabletGroup::mutable_servers() {
  // @@protoc_insertion_point(field_mutable_list:backend.PushStorageTabletsRequest.TabletGroup.servers)
  return &_impl_.servers_;
}
inline const ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo& PushStorageTabletsRequest_TabletGroup::_internal_servers(int index) const {
  return _impl_.servers_.Get(index);
}
inline const ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo& PushStorageTabletsRequest_TabletGroup::servers(int index) const {
  // @@protoc_insertion_point(field_get:backend.PushStorageTabletsRequest.TabletGroup.servers)
  return _internal_servers(index);
}
inline ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo* PushStorageTabletsRequest_TabletGroup::_internal_add_servers() {
  return _impl_.servers_.Add();
}
inline ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo* PushStorageTabletsRequest_TabletGroup::add_servers() {
  ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo* _add = _internal_add_servers();
  // @@protoc_insertion_point(field_add:backend.PushStorageTabletsRequest.TabletGroup.servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::PushStorageTabletsRequest_TabletGroup_ServerInfo >&
PushStorageTabletsRequest_TabletGroup::servers() const {
  // @@protoc_insertion_point(field_list:backend.PushStorageTabletsRequest.TabletGroup.servers)
  return _impl_.servers_;
}

// -------------------------------------------------------------------

// PushStorageTabletsRequest

// repeated .backend.PushStorageTabletsRequest.TabletGroup tablets = 1;
inline int PushStorageTabletsRequest::_internal_tablets_size() const {
  return _impl_.tablets_.size();
}
inline int PushStorageTabletsRequest::tablets_size() const {
  return _internal_tablets_size();
}
inline void PushStorageTabletsRequest::clear_tablets() {
  _impl_.tablets_.Clear();
}
inline ::backend::PushStorageTabletsRequest_TabletGroup* PushStorageTabletsRequest::mutable_tablets(int index) {
  // @@protoc_insertion_point(field_mutable:backend.PushStorageTabletsRequest.tablets)
  return _impl_.tablets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::PushStorageTabletsRequest_TabletGroup >*
PushStorageTabletsRequest::mutable_tablets() {
  // @@protoc_insertion_point(field_mutable_list:backend.PushStorageTabletsRequest.tablets)
  return &_impl_.tablets_;
}
inline const ::backend::PushStorageTabletsRequest_TabletGroup& PushStorageTabletsRequest::_internal_tablets(int index) const {
  return _impl_.tablets_.Get(index);
}
inline const ::backend::PushStorageTabletsRequest_TabletGroup& PushStorageTabletsRequest::tablets(int index) const {
  // @@protoc_insertion_point(field_get:backend.PushStorageTabletsRequest.tablets)
  return _internal_tablets(index);
}
inline ::backend::PushStorageTabletsRequest_TabletGroup* PushStorageTabletsRequest::_internal_add_tablets() {
  return _impl_.tablets_.Add();
}
inline ::backend::PushStorageTabletsRequest_TabletGroup* PushStorageTabletsRequest::add_tablets() {
  ::backend::PushStorageTabletsRequest_TabletGroup* _add = _internal_add_tablets();
  // @@protoc_insertion_point(field_add:backend.PushStorageTabletsRequest.tablets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::PushStorageTabletsRequest_TabletGroup >&
PushStorageTabletsRequest::tablets() const {
  // @@protoc_insertion_point(field_list:backend.PushStorageTabletsRequest.tablets)
  return _impl_.tablets_;
}

// -------------------------------------------------------------------

// StorageServerRequest

// string row = 1;
inline void StorageServerRequest::clear_row() {
  _impl_.row_.ClearToEmpty();
}
inline const std::string& StorageServerRequest::row() const {
  // @@protoc_insertion_point(field_get:backend.StorageServerRequest.row)
  return _internal_row();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageServerRequest::set_row(ArgT0&& arg0, ArgT... args) {
 
 _impl_.row_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.StorageServerRequest.row)
}
inline std::string* StorageServerRequest::mutable_row() {
  std::string* _s = _internal_mutable_row();
  // @@protoc_insertion_point(field_mutable:backend.StorageServerRequest.row)
  return _s;
}
inline const std::string& StorageServerRequest::_internal_row() const {
  return _impl_.row_.Get();
}
inline void StorageServerRequest::_internal_set_row(const std::string& value) {
  
  _impl_.row_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageServerRequest::_internal_mutable_row() {
  
  return _impl_.row_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageServerRequest::release_row() {
  // @@protoc_insertion_point(field_release:backend.StorageServerRequest.row)
  return _impl_.row_.Release();
}
inline void StorageServerRequest::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    
  } else {
    
  }
  _impl_.row_.SetAllocated(row, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.row_.IsDefault()) {
    _impl_.row_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.StorageServerRequest.row)
}

// string col = 2;
inline void StorageServerRequest::clear_col() {
  _impl_.col_.ClearToEmpty();
}
inline const std::string& StorageServerRequest::col() const {
  // @@protoc_insertion_point(field_get:backend.StorageServerRequest.col)
  return _internal_col();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageServerRequest::set_col(ArgT0&& arg0, ArgT... args) {
 
 _impl_.col_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.StorageServerRequest.col)
}
inline std::string* StorageServerRequest::mutable_col() {
  std::string* _s = _internal_mutable_col();
  // @@protoc_insertion_point(field_mutable:backend.StorageServerRequest.col)
  return _s;
}
inline const std::string& StorageServerRequest::_internal_col() const {
  return _impl_.col_.Get();
}
inline void StorageServerRequest::_internal_set_col(const std::string& value) {
  
  _impl_.col_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageServerRequest::_internal_mutable_col() {
  
  return _impl_.col_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageServerRequest::release_col() {
  // @@protoc_insertion_point(field_release:backend.StorageServerRequest.col)
  return _impl_.col_.Release();
}
inline void StorageServerRequest::set_allocated_col(std::string* col) {
  if (col != nullptr) {
    
  } else {
    
  }
  _impl_.col_.SetAllocated(col, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.col_.IsDefault()) {
    _impl_.col_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.StorageServerRequest.col)
}

// optional bool is_bytes = 3;
inline bool StorageServerRequest::_internal_has_is_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StorageServerRequest::has_is_bytes() const {
  return _internal_has_is_bytes();
}
inline void StorageServerRequest::clear_is_bytes() {
  _impl_.is_bytes_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool StorageServerRequest::_internal_is_bytes() const {
  return _impl_.is_bytes_;
}
inline bool StorageServerRequest::is_bytes() const {
  // @@protoc_insertion_point(field_get:backend.StorageServerRequest.is_bytes)
  return _internal_is_bytes();
}
inline void StorageServerRequest::_internal_set_is_bytes(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.is_bytes_ = value;
}
inline void StorageServerRequest::set_is_bytes(bool value) {
  _internal_set_is_bytes(value);
  // @@protoc_insertion_point(field_set:backend.StorageServerRequest.is_bytes)
}

// optional string value1 = 4;
inline bool StorageServerRequest::_internal_has_value1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StorageServerRequest::has_value1() const {
  return _internal_has_value1();
}
inline void StorageServerRequest::clear_value1() {
  _impl_.value1_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StorageServerRequest::value1() const {
  // @@protoc_insertion_point(field_get:backend.StorageServerRequest.value1)
  return _internal_value1();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageServerRequest::set_value1(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.value1_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.StorageServerRequest.value1)
}
inline std::string* StorageServerRequest::mutable_value1() {
  std::string* _s = _internal_mutable_value1();
  // @@protoc_insertion_point(field_mutable:backend.StorageServerRequest.value1)
  return _s;
}
inline const std::string& StorageServerRequest::_internal_value1() const {
  return _impl_.value1_.Get();
}
inline void StorageServerRequest::_internal_set_value1(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value1_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageServerRequest::_internal_mutable_value1() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value1_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageServerRequest::release_value1() {
  // @@protoc_insertion_point(field_release:backend.StorageServerRequest.value1)
  if (!_internal_has_value1()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.value1_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value1_.IsDefault()) {
    _impl_.value1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StorageServerRequest::set_allocated_value1(std::string* value1) {
  if (value1 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value1_.SetAllocated(value1, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value1_.IsDefault()) {
    _impl_.value1_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.StorageServerRequest.value1)
}

// optional string value2 = 5;
inline bool StorageServerRequest::_internal_has_value2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StorageServerRequest::has_value2() const {
  return _internal_has_value2();
}
inline void StorageServerRequest::clear_value2() {
  _impl_.value2_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StorageServerRequest::value2() const {
  // @@protoc_insertion_point(field_get:backend.StorageServerRequest.value2)
  return _internal_value2();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageServerRequest::set_value2(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.value2_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.StorageServerRequest.value2)
}
inline std::string* StorageServerRequest::mutable_value2() {
  std::string* _s = _internal_mutable_value2();
  // @@protoc_insertion_point(field_mutable:backend.StorageServerRequest.value2)
  return _s;
}
inline const std::string& StorageServerRequest::_internal_value2() const {
  return _impl_.value2_.Get();
}
inline void StorageServerRequest::_internal_set_value2(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value2_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageServerRequest::_internal_mutable_value2() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value2_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageServerRequest::release_value2() {
  // @@protoc_insertion_point(field_release:backend.StorageServerRequest.value2)
  if (!_internal_has_value2()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.value2_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value2_.IsDefault()) {
    _impl_.value2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StorageServerRequest::set_allocated_value2(std::string* value2) {
  if (value2 != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value2_.SetAllocated(value2, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value2_.IsDefault()) {
    _impl_.value2_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.StorageServerRequest.value2)
}

// optional bytes value1_bytes = 6;
inline bool StorageServerRequest::_internal_has_value1_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StorageServerRequest::has_value1_bytes() const {
  return _internal_has_value1_bytes();
}
inline void StorageServerRequest::clear_value1_bytes() {
  _impl_.value1_bytes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StorageServerRequest::value1_bytes() const {
  // @@protoc_insertion_point(field_get:backend.StorageServerRequest.value1_bytes)
  return _internal_value1_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageServerRequest::set_value1_bytes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.value1_bytes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.StorageServerRequest.value1_bytes)
}
inline std::string* StorageServerRequest::mutable_value1_bytes() {
  std::string* _s = _internal_mutable_value1_bytes();
  // @@protoc_insertion_point(field_mutable:backend.StorageServerRequest.value1_bytes)
  return _s;
}
inline const std::string& StorageServerRequest::_internal_value1_bytes() const {
  return _impl_.value1_bytes_.Get();
}
inline void StorageServerRequest::_internal_set_value1_bytes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.value1_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageServerRequest::_internal_mutable_value1_bytes() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.value1_bytes_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageServerRequest::release_value1_bytes() {
  // @@protoc_insertion_point(field_release:backend.StorageServerRequest.value1_bytes)
  if (!_internal_has_value1_bytes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.value1_bytes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value1_bytes_.IsDefault()) {
    _impl_.value1_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StorageServerRequest::set_allocated_value1_bytes(std::string* value1_bytes) {
  if (value1_bytes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.value1_bytes_.SetAllocated(value1_bytes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value1_bytes_.IsDefault()) {
    _impl_.value1_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.StorageServerRequest.value1_bytes)
}

// optional bytes value2_bytes = 7;
inline bool StorageServerRequest::_internal_has_value2_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StorageServerRequest::has_value2_bytes() const {
  return _internal_has_value2_bytes();
}
inline void StorageServerRequest::clear_value2_bytes() {
  _impl_.value2_bytes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& StorageServerRequest::value2_bytes() const {
  // @@protoc_insertion_point(field_get:backend.StorageServerRequest.value2_bytes)
  return _internal_value2_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageServerRequest::set_value2_bytes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000008u;
 _impl_.value2_bytes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.StorageServerRequest.value2_bytes)
}
inline std::string* StorageServerRequest::mutable_value2_bytes() {
  std::string* _s = _internal_mutable_value2_bytes();
  // @@protoc_insertion_point(field_mutable:backend.StorageServerRequest.value2_bytes)
  return _s;
}
inline const std::string& StorageServerRequest::_internal_value2_bytes() const {
  return _impl_.value2_bytes_.Get();
}
inline void StorageServerRequest::_internal_set_value2_bytes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.value2_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageServerRequest::_internal_mutable_value2_bytes() {
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.value2_bytes_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageServerRequest::release_value2_bytes() {
  // @@protoc_insertion_point(field_release:backend.StorageServerRequest.value2_bytes)
  if (!_internal_has_value2_bytes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* p = _impl_.value2_bytes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value2_bytes_.IsDefault()) {
    _impl_.value2_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StorageServerRequest::set_allocated_value2_bytes(std::string* value2_bytes) {
  if (value2_bytes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.value2_bytes_.SetAllocated(value2_bytes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value2_bytes_.IsDefault()) {
    _impl_.value2_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.StorageServerRequest.value2_bytes)
}

// bool from_primary = 8;
inline void StorageServerRequest::clear_from_primary() {
  _impl_.from_primary_ = false;
}
inline bool StorageServerRequest::_internal_from_primary() const {
  return _impl_.from_primary_;
}
inline bool StorageServerRequest::from_primary() const {
  // @@protoc_insertion_point(field_get:backend.StorageServerRequest.from_primary)
  return _internal_from_primary();
}
inline void StorageServerRequest::_internal_set_from_primary(bool value) {
  
  _impl_.from_primary_ = value;
}
inline void StorageServerRequest::set_from_primary(bool value) {
  _internal_set_from_primary(value);
  // @@protoc_insertion_point(field_set:backend.StorageServerRequest.from_primary)
}

// optional int32 sequence_number = 9;
inline bool StorageServerRequest::_internal_has_sequence_number() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StorageServerRequest::has_sequence_number() const {
  return _internal_has_sequence_number();
}
inline void StorageServerRequest::clear_sequence_number() {
  _impl_.sequence_number_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t StorageServerRequest::_internal_sequence_number() const {
  return _impl_.sequence_number_;
}
inline int32_t StorageServerRequest::sequence_number() const {
  // @@protoc_insertion_point(field_get:backend.StorageServerRequest.sequence_number)
  return _internal_sequence_number();
}
inline void StorageServerRequest::_internal_set_sequence_number(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sequence_number_ = value;
}
inline void StorageServerRequest::set_sequence_number(int32_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:backend.StorageServerRequest.sequence_number)
}

// -------------------------------------------------------------------

// StorageServerResponse

// optional string value = 1;
inline bool StorageServerResponse::_internal_has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StorageServerResponse::has_value() const {
  return _internal_has_value();
}
inline void StorageServerResponse::clear_value() {
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StorageServerResponse::value() const {
  // @@protoc_insertion_point(field_get:backend.StorageServerResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageServerResponse::set_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.StorageServerResponse.value)
}
inline std::string* StorageServerResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:backend.StorageServerResponse.value)
  return _s;
}
inline const std::string& StorageServerResponse::_internal_value() const {
  return _impl_.value_.Get();
}
inline void StorageServerResponse::_internal_set_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageServerResponse::_internal_mutable_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageServerResponse::release_value() {
  // @@protoc_insertion_point(field_release:backend.StorageServerResponse.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StorageServerResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.StorageServerResponse.value)
}

// optional bytes value_bytes = 2;
inline bool StorageServerResponse::_internal_has_value_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StorageServerResponse::has_value_bytes() const {
  return _internal_has_value_bytes();
}
inline void StorageServerResponse::clear_value_bytes() {
  _impl_.value_bytes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StorageServerResponse::value_bytes() const {
  // @@protoc_insertion_point(field_get:backend.StorageServerResponse.value_bytes)
  return _internal_value_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageServerResponse::set_value_bytes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.value_bytes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.StorageServerResponse.value_bytes)
}
inline std::string* StorageServerResponse::mutable_value_bytes() {
  std::string* _s = _internal_mutable_value_bytes();
  // @@protoc_insertion_point(field_mutable:backend.StorageServerResponse.value_bytes)
  return _s;
}
inline const std::string& StorageServerResponse::_internal_value_bytes() const {
  return _impl_.value_bytes_.Get();
}
inline void StorageServerResponse::_internal_set_value_bytes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageServerResponse::_internal_mutable_value_bytes() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_bytes_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageServerResponse::release_value_bytes() {
  // @@protoc_insertion_point(field_release:backend.StorageServerResponse.value_bytes)
  if (!_internal_has_value_bytes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.value_bytes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_bytes_.IsDefault()) {
    _impl_.value_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StorageServerResponse::set_allocated_value_bytes(std::string* value_bytes) {
  if (value_bytes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_bytes_.SetAllocated(value_bytes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_bytes_.IsDefault()) {
    _impl_.value_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.StorageServerResponse.value_bytes)
}

// -------------------------------------------------------------------

// StorageEmpty

// -------------------------------------------------------------------

// StorageGetKVStoreStateRequest

// string key = 1;
inline void StorageGetKVStoreStateRequest::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& StorageGetKVStoreStateRequest::key() const {
  // @@protoc_insertion_point(field_get:backend.StorageGetKVStoreStateRequest.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageGetKVStoreStateRequest::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.StorageGetKVStoreStateRequest.key)
}
inline std::string* StorageGetKVStoreStateRequest::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:backend.StorageGetKVStoreStateRequest.key)
  return _s;
}
inline const std::string& StorageGetKVStoreStateRequest::_internal_key() const {
  return _impl_.key_.Get();
}
inline void StorageGetKVStoreStateRequest::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageGetKVStoreStateRequest::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageGetKVStoreStateRequest::release_key() {
  // @@protoc_insertion_point(field_release:backend.StorageGetKVStoreStateRequest.key)
  return _impl_.key_.Release();
}
inline void StorageGetKVStoreStateRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.StorageGetKVStoreStateRequest.key)
}

// -------------------------------------------------------------------

// StorageGetKVStoreStateResponse_Row_Column

// string name = 1;
inline void StorageGetKVStoreStateResponse_Row_Column::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& StorageGetKVStoreStateResponse_Row_Column::name() const {
  // @@protoc_insertion_point(field_get:backend.StorageGetKVStoreStateResponse.Row.Column.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageGetKVStoreStateResponse_Row_Column::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.StorageGetKVStoreStateResponse.Row.Column.name)
}
inline std::string* StorageGetKVStoreStateResponse_Row_Column::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:backend.StorageGetKVStoreStateResponse.Row.Column.name)
  return _s;
}
inline const std::string& StorageGetKVStoreStateResponse_Row_Column::_internal_name() const {
  return _impl_.name_.Get();
}
inline void StorageGetKVStoreStateResponse_Row_Column::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageGetKVStoreStateResponse_Row_Column::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageGetKVStoreStateResponse_Row_Column::release_name() {
  // @@protoc_insertion_point(field_release:backend.StorageGetKVStoreStateResponse.Row.Column.name)
  return _impl_.name_.Release();
}
inline void StorageGetKVStoreStateResponse_Row_Column::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.StorageGetKVStoreStateResponse.Row.Column.name)
}

// bytes data = 2;
inline void StorageGetKVStoreStateResponse_Row_Column::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& StorageGetKVStoreStateResponse_Row_Column::data() const {
  // @@protoc_insertion_point(field_get:backend.StorageGetKVStoreStateResponse.Row.Column.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageGetKVStoreStateResponse_Row_Column::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.StorageGetKVStoreStateResponse.Row.Column.data)
}
inline std::string* StorageGetKVStoreStateResponse_Row_Column::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:backend.StorageGetKVStoreStateResponse.Row.Column.data)
  return _s;
}
inline const std::string& StorageGetKVStoreStateResponse_Row_Column::_internal_data() const {
  return _impl_.data_.Get();
}
inline void StorageGetKVStoreStateResponse_Row_Column::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageGetKVStoreStateResponse_Row_Column::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageGetKVStoreStateResponse_Row_Column::release_data() {
  // @@protoc_insertion_point(field_release:backend.StorageGetKVStoreStateResponse.Row.Column.data)
  return _impl_.data_.Release();
}
inline void StorageGetKVStoreStateResponse_Row_Column::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.StorageGetKVStoreStateResponse.Row.Column.data)
}

// -------------------------------------------------------------------

// StorageGetKVStoreStateResponse_Row

// string name = 1;
inline void StorageGetKVStoreStateResponse_Row::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& StorageGetKVStoreStateResponse_Row::name() const {
  // @@protoc_insertion_point(field_get:backend.StorageGetKVStoreStateResponse.Row.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorageGetKVStoreStateResponse_Row::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.StorageGetKVStoreStateResponse.Row.name)
}
inline std::string* StorageGetKVStoreStateResponse_Row::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:backend.StorageGetKVStoreStateResponse.Row.name)
  return _s;
}
inline const std::string& StorageGetKVStoreStateResponse_Row::_internal_name() const {
  return _impl_.name_.Get();
}
inline void StorageGetKVStoreStateResponse_Row::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* StorageGetKVStoreStateResponse_Row::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* StorageGetKVStoreStateResponse_Row::release_name() {
  // @@protoc_insertion_point(field_release:backend.StorageGetKVStoreStateResponse.Row.name)
  return _impl_.name_.Release();
}
inline void StorageGetKVStoreStateResponse_Row::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.StorageGetKVStoreStateResponse.Row.name)
}

// repeated .backend.StorageGetKVStoreStateResponse.Row.Column columns = 2;
inline int StorageGetKVStoreStateResponse_Row::_internal_columns_size() const {
  return _impl_.columns_.size();
}
inline int StorageGetKVStoreStateResponse_Row::columns_size() const {
  return _internal_columns_size();
}
inline void StorageGetKVStoreStateResponse_Row::clear_columns() {
  _impl_.columns_.Clear();
}
inline ::backend::StorageGetKVStoreStateResponse_Row_Column* StorageGetKVStoreStateResponse_Row::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:backend.StorageGetKVStoreStateResponse.Row.columns)
  return _impl_.columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::StorageGetKVStoreStateResponse_Row_Column >*
StorageGetKVStoreStateResponse_Row::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:backend.StorageGetKVStoreStateResponse.Row.columns)
  return &_impl_.columns_;
}
inline const ::backend::StorageGetKVStoreStateResponse_Row_Column& StorageGetKVStoreStateResponse_Row::_internal_columns(int index) const {
  return _impl_.columns_.Get(index);
}
inline const ::backend::StorageGetKVStoreStateResponse_Row_Column& StorageGetKVStoreStateResponse_Row::columns(int index) const {
  // @@protoc_insertion_point(field_get:backend.StorageGetKVStoreStateResponse.Row.columns)
  return _internal_columns(index);
}
inline ::backend::StorageGetKVStoreStateResponse_Row_Column* StorageGetKVStoreStateResponse_Row::_internal_add_columns() {
  return _impl_.columns_.Add();
}
inline ::backend::StorageGetKVStoreStateResponse_Row_Column* StorageGetKVStoreStateResponse_Row::add_columns() {
  ::backend::StorageGetKVStoreStateResponse_Row_Column* _add = _internal_add_columns();
  // @@protoc_insertion_point(field_add:backend.StorageGetKVStoreStateResponse.Row.columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::StorageGetKVStoreStateResponse_Row_Column >&
StorageGetKVStoreStateResponse_Row::columns() const {
  // @@protoc_insertion_point(field_list:backend.StorageGetKVStoreStateResponse.Row.columns)
  return _impl_.columns_;
}

// -------------------------------------------------------------------

// StorageGetKVStoreStateResponse

// repeated .backend.StorageGetKVStoreStateResponse.Row rows = 1;
inline int StorageGetKVStoreStateResponse::_internal_rows_size() const {
  return _impl_.rows_.size();
}
inline int StorageGetKVStoreStateResponse::rows_size() const {
  return _internal_rows_size();
}
inline void StorageGetKVStoreStateResponse::clear_rows() {
  _impl_.rows_.Clear();
}
inline ::backend::StorageGetKVStoreStateResponse_Row* StorageGetKVStoreStateResponse::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:backend.StorageGetKVStoreStateResponse.rows)
  return _impl_.rows_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::StorageGetKVStoreStateResponse_Row >*
StorageGetKVStoreStateResponse::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:backend.StorageGetKVStoreStateResponse.rows)
  return &_impl_.rows_;
}
inline const ::backend::StorageGetKVStoreStateResponse_Row& StorageGetKVStoreStateResponse::_internal_rows(int index) const {
  return _impl_.rows_.Get(index);
}
inline const ::backend::StorageGetKVStoreStateResponse_Row& StorageGetKVStoreStateResponse::rows(int index) const {
  // @@protoc_insertion_point(field_get:backend.StorageGetKVStoreStateResponse.rows)
  return _internal_rows(index);
}
inline ::backend::StorageGetKVStoreStateResponse_Row* StorageGetKVStoreStateResponse::_internal_add_rows() {
  return _impl_.rows_.Add();
}
inline ::backend::StorageGetKVStoreStateResponse_Row* StorageGetKVStoreStateResponse::add_rows() {
  ::backend::StorageGetKVStoreStateResponse_Row* _add = _internal_add_rows();
  // @@protoc_insertion_point(field_add:backend.StorageGetKVStoreStateResponse.rows)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::backend::StorageGetKVStoreStateResponse_Row >&
StorageGetKVStoreStateResponse::rows() const {
  // @@protoc_insertion_point(field_list:backend.StorageGetKVStoreStateResponse.rows)
  return _impl_.rows_;
}

// -------------------------------------------------------------------

// RequestLatestTabletStateRequest

// string tablet_range = 1;
inline void RequestLatestTabletStateRequest::clear_tablet_range() {
  _impl_.tablet_range_.ClearToEmpty();
}
inline const std::string& RequestLatestTabletStateRequest::tablet_range() const {
  // @@protoc_insertion_point(field_get:backend.RequestLatestTabletStateRequest.tablet_range)
  return _internal_tablet_range();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestLatestTabletStateRequest::set_tablet_range(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tablet_range_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.RequestLatestTabletStateRequest.tablet_range)
}
inline std::string* RequestLatestTabletStateRequest::mutable_tablet_range() {
  std::string* _s = _internal_mutable_tablet_range();
  // @@protoc_insertion_point(field_mutable:backend.RequestLatestTabletStateRequest.tablet_range)
  return _s;
}
inline const std::string& RequestLatestTabletStateRequest::_internal_tablet_range() const {
  return _impl_.tablet_range_.Get();
}
inline void RequestLatestTabletStateRequest::_internal_set_tablet_range(const std::string& value) {
  
  _impl_.tablet_range_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestLatestTabletStateRequest::_internal_mutable_tablet_range() {
  
  return _impl_.tablet_range_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestLatestTabletStateRequest::release_tablet_range() {
  // @@protoc_insertion_point(field_release:backend.RequestLatestTabletStateRequest.tablet_range)
  return _impl_.tablet_range_.Release();
}
inline void RequestLatestTabletStateRequest::set_allocated_tablet_range(std::string* tablet_range) {
  if (tablet_range != nullptr) {
    
  } else {
    
  }
  _impl_.tablet_range_.SetAllocated(tablet_range, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tablet_range_.IsDefault()) {
    _impl_.tablet_range_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.RequestLatestTabletStateRequest.tablet_range)
}

// int32 checkpoint_version = 2;
inline void RequestLatestTabletStateRequest::clear_checkpoint_version() {
  _impl_.checkpoint_version_ = 0;
}
inline int32_t RequestLatestTabletStateRequest::_internal_checkpoint_version() const {
  return _impl_.checkpoint_version_;
}
inline int32_t RequestLatestTabletStateRequest::checkpoint_version() const {
  // @@protoc_insertion_point(field_get:backend.RequestLatestTabletStateRequest.checkpoint_version)
  return _internal_checkpoint_version();
}
inline void RequestLatestTabletStateRequest::_internal_set_checkpoint_version(int32_t value) {
  
  _impl_.checkpoint_version_ = value;
}
inline void RequestLatestTabletStateRequest::set_checkpoint_version(int32_t value) {
  _internal_set_checkpoint_version(value);
  // @@protoc_insertion_point(field_set:backend.RequestLatestTabletStateRequest.checkpoint_version)
}

// int32 log_length = 3;
inline void RequestLatestTabletStateRequest::clear_log_length() {
  _impl_.log_length_ = 0;
}
inline int32_t RequestLatestTabletStateRequest::_internal_log_length() const {
  return _impl_.log_length_;
}
inline int32_t RequestLatestTabletStateRequest::log_length() const {
  // @@protoc_insertion_point(field_get:backend.RequestLatestTabletStateRequest.log_length)
  return _internal_log_length();
}
inline void RequestLatestTabletStateRequest::_internal_set_log_length(int32_t value) {
  
  _impl_.log_length_ = value;
}
inline void RequestLatestTabletStateRequest::set_log_length(int32_t value) {
  _internal_set_log_length(value);
  // @@protoc_insertion_point(field_set:backend.RequestLatestTabletStateRequest.log_length)
}

// string address = 4;
inline void RequestLatestTabletStateRequest::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& RequestLatestTabletStateRequest::address() const {
  // @@protoc_insertion_point(field_get:backend.RequestLatestTabletStateRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestLatestTabletStateRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.RequestLatestTabletStateRequest.address)
}
inline std::string* RequestLatestTabletStateRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:backend.RequestLatestTabletStateRequest.address)
  return _s;
}
inline const std::string& RequestLatestTabletStateRequest::_internal_address() const {
  return _impl_.address_.Get();
}
inline void RequestLatestTabletStateRequest::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestLatestTabletStateRequest::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestLatestTabletStateRequest::release_address() {
  // @@protoc_insertion_point(field_release:backend.RequestLatestTabletStateRequest.address)
  return _impl_.address_.Release();
}
inline void RequestLatestTabletStateRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.RequestLatestTabletStateRequest.address)
}

// -------------------------------------------------------------------

// RequestLatestTabletStateResponse

// -------------------------------------------------------------------

// PushCheckpointPartitionRequest

// int32 checkpoint_version = 1;
inline void PushCheckpointPartitionRequest::clear_checkpoint_version() {
  _impl_.checkpoint_version_ = 0;
}
inline int32_t PushCheckpointPartitionRequest::_internal_checkpoint_version() const {
  return _impl_.checkpoint_version_;
}
inline int32_t PushCheckpointPartitionRequest::checkpoint_version() const {
  // @@protoc_insertion_point(field_get:backend.PushCheckpointPartitionRequest.checkpoint_version)
  return _internal_checkpoint_version();
}
inline void PushCheckpointPartitionRequest::_internal_set_checkpoint_version(int32_t value) {
  
  _impl_.checkpoint_version_ = value;
}
inline void PushCheckpointPartitionRequest::set_checkpoint_version(int32_t value) {
  _internal_set_checkpoint_version(value);
  // @@protoc_insertion_point(field_set:backend.PushCheckpointPartitionRequest.checkpoint_version)
}

// string tablet_range = 2;
inline void PushCheckpointPartitionRequest::clear_tablet_range() {
  _impl_.tablet_range_.ClearToEmpty();
}
inline const std::string& PushCheckpointPartitionRequest::tablet_range() const {
  // @@protoc_insertion_point(field_get:backend.PushCheckpointPartitionRequest.tablet_range)
  return _internal_tablet_range();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushCheckpointPartitionRequest::set_tablet_range(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tablet_range_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.PushCheckpointPartitionRequest.tablet_range)
}
inline std::string* PushCheckpointPartitionRequest::mutable_tablet_range() {
  std::string* _s = _internal_mutable_tablet_range();
  // @@protoc_insertion_point(field_mutable:backend.PushCheckpointPartitionRequest.tablet_range)
  return _s;
}
inline const std::string& PushCheckpointPartitionRequest::_internal_tablet_range() const {
  return _impl_.tablet_range_.Get();
}
inline void PushCheckpointPartitionRequest::_internal_set_tablet_range(const std::string& value) {
  
  _impl_.tablet_range_.Set(value, GetArenaForAllocation());
}
inline std::string* PushCheckpointPartitionRequest::_internal_mutable_tablet_range() {
  
  return _impl_.tablet_range_.Mutable(GetArenaForAllocation());
}
inline std::string* PushCheckpointPartitionRequest::release_tablet_range() {
  // @@protoc_insertion_point(field_release:backend.PushCheckpointPartitionRequest.tablet_range)
  return _impl_.tablet_range_.Release();
}
inline void PushCheckpointPartitionRequest::set_allocated_tablet_range(std::string* tablet_range) {
  if (tablet_range != nullptr) {
    
  } else {
    
  }
  _impl_.tablet_range_.SetAllocated(tablet_range, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tablet_range_.IsDefault()) {
    _impl_.tablet_range_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.PushCheckpointPartitionRequest.tablet_range)
}

// bytes content = 3;
inline void PushCheckpointPartitionRequest::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& PushCheckpointPartitionRequest::content() const {
  // @@protoc_insertion_point(field_get:backend.PushCheckpointPartitionRequest.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushCheckpointPartitionRequest::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.PushCheckpointPartitionRequest.content)
}
inline std::string* PushCheckpointPartitionRequest::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:backend.PushCheckpointPartitionRequest.content)
  return _s;
}
inline const std::string& PushCheckpointPartitionRequest::_internal_content() const {
  return _impl_.content_.Get();
}
inline void PushCheckpointPartitionRequest::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* PushCheckpointPartitionRequest::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* PushCheckpointPartitionRequest::release_content() {
  // @@protoc_insertion_point(field_release:backend.PushCheckpointPartitionRequest.content)
  return _impl_.content_.Release();
}
inline void PushCheckpointPartitionRequest::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.PushCheckpointPartitionRequest.content)
}

// bool is_last_partition = 4;
inline void PushCheckpointPartitionRequest::clear_is_last_partition() {
  _impl_.is_last_partition_ = false;
}
inline bool PushCheckpointPartitionRequest::_internal_is_last_partition() const {
  return _impl_.is_last_partition_;
}
inline bool PushCheckpointPartitionRequest::is_last_partition() const {
  // @@protoc_insertion_point(field_get:backend.PushCheckpointPartitionRequest.is_last_partition)
  return _internal_is_last_partition();
}
inline void PushCheckpointPartitionRequest::_internal_set_is_last_partition(bool value) {
  
  _impl_.is_last_partition_ = value;
}
inline void PushCheckpointPartitionRequest::set_is_last_partition(bool value) {
  _internal_set_is_last_partition(value);
  // @@protoc_insertion_point(field_set:backend.PushCheckpointPartitionRequest.is_last_partition)
}

// -------------------------------------------------------------------

// PushCheckpointPartitionResponse

// -------------------------------------------------------------------

// PushLogRequest

// string tablet_range = 1;
inline void PushLogRequest::clear_tablet_range() {
  _impl_.tablet_range_.ClearToEmpty();
}
inline const std::string& PushLogRequest::tablet_range() const {
  // @@protoc_insertion_point(field_get:backend.PushLogRequest.tablet_range)
  return _internal_tablet_range();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushLogRequest::set_tablet_range(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tablet_range_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.PushLogRequest.tablet_range)
}
inline std::string* PushLogRequest::mutable_tablet_range() {
  std::string* _s = _internal_mutable_tablet_range();
  // @@protoc_insertion_point(field_mutable:backend.PushLogRequest.tablet_range)
  return _s;
}
inline const std::string& PushLogRequest::_internal_tablet_range() const {
  return _impl_.tablet_range_.Get();
}
inline void PushLogRequest::_internal_set_tablet_range(const std::string& value) {
  
  _impl_.tablet_range_.Set(value, GetArenaForAllocation());
}
inline std::string* PushLogRequest::_internal_mutable_tablet_range() {
  
  return _impl_.tablet_range_.Mutable(GetArenaForAllocation());
}
inline std::string* PushLogRequest::release_tablet_range() {
  // @@protoc_insertion_point(field_release:backend.PushLogRequest.tablet_range)
  return _impl_.tablet_range_.Release();
}
inline void PushLogRequest::set_allocated_tablet_range(std::string* tablet_range) {
  if (tablet_range != nullptr) {
    
  } else {
    
  }
  _impl_.tablet_range_.SetAllocated(tablet_range, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tablet_range_.IsDefault()) {
    _impl_.tablet_range_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.PushLogRequest.tablet_range)
}

// bytes content = 2;
inline void PushLogRequest::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& PushLogRequest::content() const {
  // @@protoc_insertion_point(field_get:backend.PushLogRequest.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushLogRequest::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backend.PushLogRequest.content)
}
inline std::string* PushLogRequest::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:backend.PushLogRequest.content)
  return _s;
}
inline const std::string& PushLogRequest::_internal_content() const {
  return _impl_.content_.Get();
}
inline void PushLogRequest::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* PushLogRequest::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* PushLogRequest::release_content() {
  // @@protoc_insertion_point(field_release:backend.PushLogRequest.content)
  return _impl_.content_.Release();
}
inline void PushLogRequest::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backend.PushLogRequest.content)
}

// -------------------------------------------------------------------

// PushLogResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace backend

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_storageserver_2eproto
